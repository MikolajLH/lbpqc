{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LBPQC","text":"<p>LBPQC - Lattice Based Post Quantum Cryptohraphy is a python package aggregating various lattice's cryptographic and cryptanalytical primitives.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install using pip:</p> <pre><code>pip install lbpqc\n</code></pre>"},{"location":"api/types/","title":"Types","text":"<p>LBPQC is build on top of <code>numpy</code> so the most common type on which operations are performed is <code>numpy.ndarray</code>.</p> <p>However in order to improve clarity of the code we rely heavily on python's type aliases that allow to differentiate between e.g vectors and matrices (which both are represented as <code>ndarray</code>).</p>"},{"location":"api/types/#int","title":"<code>int</code>","text":"<p>Aliases for <code>int</code> are only used as an information about what kind of result does the functino returns.</p>"},{"location":"api/types/#modint","title":"<code>ModInt</code>","text":"<pre><code>type ModInt = int\n</code></pre> <p>Represents integers from interval \\([0, q)\\) for some positive integer \\(q\\).</p>"},{"location":"api/types/#centeredmodint","title":"<code>CenteredModInt</code>","text":"<pre><code>type CenteredModInt = int\n</code></pre> <p>Represents integers from interval \\([-\\frac{q}{2}, \\frac{q}{2})\\) for some positive integer \\(q\\).</p>"},{"location":"api/types/#vector","title":"<code>Vector</code>","text":""},{"location":"api/types/#vector_1","title":"<code>Vector</code>","text":"<pre><code>type Vector = np.ndarray\n</code></pre>"},{"location":"api/types/#vectorfloat","title":"<code>VectorFloat</code>","text":"<pre><code>type Vector = np.ndarray[float]\n</code></pre>"},{"location":"api/types/#vectorint","title":"<code>VectorInt</code>","text":"<pre><code>type Vector = np.ndarray[int]\n</code></pre>"},{"location":"api/types/#vectormodint","title":"<code>VectorModInt</code>","text":"<pre><code>type Vector = np.ndarray[int]\n</code></pre>"},{"location":"api/types/#vectorcenteredmodint","title":"<code>VectorCenteredModInt</code>","text":"<pre><code>type Vector = np.ndarray[int]\n</code></pre>"},{"location":"api/types/#matrix","title":"<code>Matrix</code>","text":""},{"location":"api/types/#matrix_1","title":"<code>Matrix</code>","text":"<pre><code>type Matrix = np.ndarray\n</code></pre>"},{"location":"api/types/#matrixfloat","title":"<code>MatrixFloat</code>","text":"<pre><code>type Matrix = np.ndarray[float]\n</code></pre>"},{"location":"api/types/#matrixint","title":"<code>MatrixInt</code>","text":"<pre><code>type Matrix = np.ndarray[int]\n</code></pre>"},{"location":"api/types/#matrixmodint","title":"<code>MatrixModInt</code>","text":"<pre><code>type Matrix = np.ndarray[int]\n</code></pre>"},{"location":"api/types/#matrixcenteredmodint","title":"<code>MatrixCenteredModInt</code>","text":"<pre><code>type Matrix = np.ndarray[int]\n</code></pre>"},{"location":"api/modules/","title":"Modules","text":"<ul> <li>lbpqc.lattice</li> <li>lbpqc.matrix</li> <li>lbpqc.polynomial</li> <li>lbpqc.rng</li> <li>lbpqc.integer</li> </ul>"},{"location":"api/modules/integer/","title":"Integer","text":""},{"location":"api/modules/integer/#src.lbpqc.primitives.integer.integer_ring.LWR_rounding","title":"<code>LWR_rounding(a, q, p)</code>","text":"<p>LWR rounding function, that maps elements from \\(\\mathbb{Z}_q\\) to elements from \\(\\mathbb{Z}_p\\) for some positive integers \\(p\\) and \\(q\\).</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>Integer to be rounded.</p> required <code>q</code> <code>int</code> <p>Modulus of domain ring \\(\\mathbb{Z}_q\\).</p> required <code>p</code> <code>int</code> <p>Modulus of codomain ring \\(\\mathbb{Z}_p\\).</p> required <p>Returns:</p> Type Description <code>ModInt</code> <p>Integer \\(c \\in [0,p)\\).</p> Source code in <code>src/lbpqc/primitives/integer/integer_ring.py</code> <pre><code>@np.vectorize\ndef LWR_rounding(a: int, q: int, p: int) -&gt; ModInt:\n    r'''\n    **LWR** rounding function, that maps elements from $\\mathbb{Z}_q$ to elements from $\\mathbb{Z}_p$ for some positive integers $p$ and $q$.\n\n    Args:\n        a: Integer to be rounded.\n        q: Modulus of domain ring $\\mathbb{Z}_q$.\n        p: Modulus of codomain ring $\\mathbb{Z}_p$.\n\n    Returns:\n        Integer $c \\in [0,p)$.\n    '''\n    return math.floor((p/q) * a) % p\n</code></pre>"},{"location":"api/modules/integer/#src.lbpqc.primitives.integer.integer_ring.center_mod_reduce","title":"<code>center_mod_reduce(a, m, right_closed=True)</code>","text":"<p>Reduces integer \\(a\\) to it's equivalence class modulo \\(m\\) represented as an interval centered around zero. Depending on the <code>right_closed</code> parameter, the interval is either $$ \\left(-\\frac{m}{2}, \\frac{m}{2}\\right] $$ or $$ \\left[-\\frac{m}{2}, \\frac{m}{2}\\right) $$</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>integer or numpy array to be reduced.</p> required <code>m</code> <code>int</code> <p>positive modulus for the congruence relation.</p> required <code>right_closed</code> <code>bool</code> <p>parameter deciding which side of half-open interval is closed.</p> <code>True</code> <p>Returns:</p> Type Description <code>CenteredModInt</code> <p>Integer or numpy array with entries reduced around zero.</p> Source code in <code>src/lbpqc/primitives/integer/integer_ring.py</code> <pre><code>@np.vectorize\ndef center_mod_reduce(a: int, m: int, right_closed: bool = True) -&gt; CenteredModInt:\n    r'''\n    Reduces integer $a$ to it's equivalence class modulo $m$ represented as an interval **centered around zero**.\n    Depending on the `right_closed` parameter, the interval is either\n    $$\n    \\left(-\\frac{m}{2}, \\frac{m}{2}\\right]\n    $$\n    or\n    $$\n    \\left[-\\frac{m}{2}, \\frac{m}{2}\\right)\n    $$\n\n    Args:\n        a: integer or numpy array to be reduced.\n        m: positive modulus for the congruence relation.\n        right_closed: parameter deciding which side of half-open interval is closed.\n\n    Returns:\n        Integer or numpy array with entries reduced around zero.\n    '''\n    if right_closed:\n        return ((a + m // 2) % m) - m // 2\n    else:\n        return ((a + 1 + m // 2) % m) - m // 2 - 1\n</code></pre>"},{"location":"api/modules/integer/#src.lbpqc.primitives.integer.integer_ring.eea","title":"<code>eea(a, b)</code>","text":"<p>Implementation of extended Euclidean algorithm, i.e. algorithm that for integers \\(a\\) and \\(b\\) computes their \\(\\gcd\\) and coefficients of B\u00e9zout's identity, which are integers \\(s\\) and \\(t\\) such that $$ sa + tb = \\gcd(a,b) $$</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>integer a.</p> required <code>b</code> <code>int</code> <p>integer b.</p> required <p>Returns:</p> Type Description <code>Tuple[int, int, int]</code> <p>Tuple (gcd(a,b), s, t).</p> Source code in <code>src/lbpqc/primitives/integer/integer_ring.py</code> <pre><code>def eea(a: int, b: int) -&gt; Tuple[int,int,int]:\n    r'''\n    Implementation of **extended Euclidean algorithm**, i.e. algorithm that for integers $a$ and $b$ computes their $\\gcd$ and\n    coefficients of **B\u00e9zout's identity**, which are integers $s$ and $t$ such that\n    $$\n    sa + tb = \\gcd(a,b)\n    $$\n\n    Args:\n        a: integer a.\n        b: integer b.\n\n    Returns:\n        Tuple (gcd(a,b), s, t).\n    '''\n    old_s, s = 1, 0\n    old_r, r = a, b\n    while r != 0:\n        q = old_r // r\n        old_r, r = r, old_r - q * r\n        old_s, s = s, old_s - q * s\n\n    t = 0 if b == 0 else (old_r - old_s * a) // b\n    s = old_s\n    gcd = old_r\n    return gcd, s, t\n</code></pre>"},{"location":"api/modules/integer/#src.lbpqc.primitives.integer.integer_ring.mod_reduce","title":"<code>mod_reduce(a, m)</code>","text":"<p>Reduces integer \\(a\\) to it's equivalence class modulo \\(m\\) represented as integer in the interval \\([0,m)\\).</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>integer or numpy array to be reduced.</p> required <code>m</code> <code>int</code> <p>positive modulus for the congruence relation.</p> required <p>Returns:</p> Type Description <code>ModInt</code> <p>Integer or numpy array with entries from interval \\([0, \\text{m})\\).</p> Source code in <code>src/lbpqc/primitives/integer/integer_ring.py</code> <pre><code>@np.vectorize\ndef mod_reduce(a: int, m: int) -&gt; ModInt:\n    r'''\n    Reduces integer $a$ to it's equivalence class modulo $m$ represented as integer in the interval $[0,m)$.\n\n    Args:\n        a: integer or numpy array to be reduced.\n        m: positive modulus for the congruence relation.\n\n    Returns:\n        Integer or numpy array with entries from interval $[0, \\text{m})$.\n    '''\n    return a % m\n</code></pre>"},{"location":"api/modules/integer/#src.lbpqc.primitives.integer.integer_ring.modinv","title":"<code>modinv(a, modulus)</code>","text":"<p>Computes multiplicative modular inverse of integer \\(a\\) for a given modulus. If the inverse does not exists, i.e. \\(\\gcd(a, \\text{modulus}) \\neq 1\\) then raises <code>ValueError</code>.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>integer, which inverse we want to calculate.</p> required <code>modulus</code> <code>int</code> <p>positive modulus.</p> required <p>Returns:</p> Type Description <code>ModInt</code> <p>Integer \\(r\\) from interval \\([0, \\text{modulus})\\) that satisfies \\(a \\cdot r \\equiv 1 \\mod \\text{modulus}\\).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If \\(\\gcd(a, \\text{modulus}) \\neq 1\\).</p> Source code in <code>src/lbpqc/primitives/integer/integer_ring.py</code> <pre><code>def modinv(a: int, modulus: int) -&gt; ModInt:\n    r'''Computes multiplicative modular inverse of integer $a$ for a given modulus.\n    If the inverse does not exists, i.e. $\\gcd(a, \\text{modulus}) \\neq 1$ then raises `ValueError`.\n\n    Args:\n        a: integer, which inverse we want to calculate.\n        modulus: positive modulus.\n\n    Returns:\n        Integer $r$ from interval $[0, \\text{modulus})$ that satisfies $a \\cdot r \\equiv 1 \\mod \\text{modulus}$.\n\n    Raises:\n        ValueError: If $\\gcd(a, \\text{modulus}) \\neq 1$.\n    '''\n    gcd, a_inv, _ = eea(a, modulus)\n    if gcd != 1:\n        raise ValueError(f\"Modular inverse of {a} mod {modulus} does not exist gcd is equal to {gcd}\")\n\n    return a_inv % modulus\n</code></pre>"},{"location":"api/modules/integer/#src.lbpqc.primitives.integer.integer_ring.modpow","title":"<code>modpow(a, r, modulus)</code>","text":"<p>Computes $$ a^{r} \\mod \\text{modulus} $$ using multiply and halve powering algorithm for groups.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>Base.</p> required <code>r</code> <code>int</code> <p>Exponent.</p> required <code>modulus</code> <code>int</code> <p>Positive modulus.</p> required <p>Returns:</p> Type Description <code>ModInt</code> <p>Integer \\(c \\in [0, \\text{modulus})\\) such that \\(c \\equiv a^r \\mod \\text{modulus}\\).</p> Source code in <code>src/lbpqc/primitives/integer/integer_ring.py</code> <pre><code>def modpow(a: int, r: int, modulus: int) -&gt; ModInt:\n    r'''Computes\n    $$\n    a^{r} \\mod \\text{modulus}\n    $$\n    using *multiply and halve* powering algorithm for groups.\n\n    Args:\n        a: Base.\n        r: Exponent.\n        modulus: Positive modulus.\n\n    Returns:\n        Integer $c \\in [0, \\text{modulus})$ such that $c \\equiv a^r \\mod \\text{modulus}$.\n\n    '''\n    if r &lt; 0:\n        return modpow(modinv(a, modulus), -r, modulus)\n\n    y, z = 1, a\n    while r != 0:\n        if r % 2 == 1:\n            y = (y * z) % modulus\n        r //= 2\n        z = (z * z) % modulus\n    return y\n</code></pre>"},{"location":"api/modules/integer/#src.lbpqc.primitives.integer.prime.fermat_primality_test","title":"<code>fermat_primality_test(p, s, int_gen=None)</code>","text":"<p>Fermat's primality test</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>int</code> <p>.</p> required <code>s</code> <code>int</code> <p>.</p> required Source code in <code>src/lbpqc/primitives/integer/prime.py</code> <pre><code>def fermat_primality_test(p: int, s: int, int_gen= None):\n    r'''Fermat's primality test\n\n    Args:\n        p:.\n        s:.\n        int_gen.\n    '''\n\n    if p in SMALL_PRIMES:\n        return True\n\n    if int_gen is None:\n        int_gen = lambda a, b: random.randint(a, b - 1)\n\n    for _ in range(s):\n        a = int_gen(2, p - 2)\n        if integer_ring.modpow(a, p - 1, p) == 1:\n            return False\n    return True\n</code></pre>"},{"location":"api/modules/integer/#src.lbpqc.primitives.integer.prime.is_prime","title":"<code>is_prime(p)</code>","text":"<p>Equivalent to <code>miller_rabin_primality_test(p, 20)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>int</code> <p>Prime candidate.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if p is prime (at least according to miller rabin test) False otherwise.</p> Source code in <code>src/lbpqc/primitives/integer/prime.py</code> <pre><code>def is_prime(p: int) -&gt; bool:\n    r'''\n    Equivalent to `miller_rabin_primality_test(p, 20)`.\n\n    Args:\n        p: Prime candidate.\n\n    Returns:\n        True if p is prime (at least according to miller rabin test) False otherwise.\n    '''\n\n    if p in SMALL_PRIMES:\n        return True\n\n    return miller_rabin_primality_test(p, 20, lambda a, b: random.randint(a, b - 1))\n</code></pre>"},{"location":"api/modules/integer/#src.lbpqc.primitives.integer.prime.miller_rabin_primality_test","title":"<code>miller_rabin_primality_test(p, s, int_gen=None)</code>","text":"<p>Miller-Rabin primality test</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>int</code> <p>.</p> required <code>s</code> <code>int</code> <p>.</p> required <code>int_gen</code> <p>.</p> <code>None</code> <p>Returns:</p> Type Description <p>.</p> Source code in <code>src/lbpqc/primitives/integer/prime.py</code> <pre><code>def miller_rabin_primality_test(p: int, s: int, int_gen= None):\n    r''' Miller-Rabin primality test\n\n    Args:\n        p:.\n        s:.\n        int_gen:.\n\n    Returns:\n        .\n    '''\n    if p in SMALL_PRIMES:\n        return True\n\n    if p == 1 or p % 2 == 0 or p % 3 == 0 or p % 5 == 0:\n        return False\n\n    if int_gen is None:\n        int_gen = lambda a, b: random.randint(a, b - 1)\n\n    u = 0\n    r = p - 1\n    while r % 2 == 0:\n        u += 1\n        r //= 2\n\n    for _ in range(s):\n        a = int_gen(2, p - 2)\n        z = integer_ring.modpow(a, r, p)\n        if z != 1 and z != p - 1:\n            for _ in range(u - 1):\n                z = (z * z) % p\n                if z == 1:\n                    return False\n            if z != p - 1:\n                return False\n        return True\n</code></pre>"},{"location":"api/modules/lattice/","title":"Lattice","text":""},{"location":"api/modules/lattice/#src.lbpqc.primitives.lattice.embeddings.CVP_embedding","title":"<code>CVP_embedding(lattice_basis, v, M=1)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/lattice/embeddings.py</code> <pre><code>def CVP_embedding(lattice_basis: SquareMatrix, v: Vector, M = 1) -&gt; SquareMatrix:\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    assert v.shape[0] == lattice_basis.shape[0]\n    n = lattice_basis.shape[0]\n\n\n    return np.block([[lattice_basis, np.zeros((n, 1), dtype=lattice_basis.dtype)], [v, np.array([M])]])\n</code></pre>"},{"location":"api/modules/lattice/#src.lbpqc.primitives.lattice.embeddings.bai_galbraith_embedding","title":"<code>bai_galbraith_embedding(A, b, q)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/lattice/embeddings.py</code> <pre><code>def bai_galbraith_embedding(A: MatrixInt, b: VectorInt, q: int) -&gt; SquareMatrixInt:\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    #B = np.block([np.identity(m, int), A, -b.reshape(-1,1)])\n    pass\n</code></pre>"},{"location":"api/modules/lattice/#src.lbpqc.primitives.lattice.embeddings.dual_q_ary_basis","title":"<code>dual_q_ary_basis(A, q)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/lattice/embeddings.py</code> <pre><code>def dual_q_ary_basis(A: MatrixInt, q: int) -&gt; MatrixModInt:\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    m, n = A.shape\n    Y = matrix.mod_left_kernel(A,q)\n    return np.block([[Y], [ np.zeros((n, m - n), dtype=np.int64), q * np.identity(n, int)]])\n</code></pre>"},{"location":"api/modules/lattice/#src.lbpqc.primitives.lattice.embeddings.q_ary_basis","title":"<code>q_ary_basis(A, q)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/lattice/embeddings.py</code> <pre><code>def q_ary_basis(A: MatrixInt, q: int) -&gt; MatrixModInt:\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    m, n = A.shape\n    B = np.block([[A.T], [q * np.identity(m, int)]])\n    H, *_ = matrix.HNF(B)\n    return H[:m, :m]\n</code></pre>"},{"location":"api/modules/lattice/#src.lbpqc.primitives.lattice.embeddings.subset_sum_lattice","title":"<code>subset_sum_lattice(sequence, S)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/lattice/embeddings.py</code> <pre><code>def subset_sum_lattice(sequence, S):\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    n = len(sequence)\n    M = np.identity(n + 1, dtype=float) * 2\n    M[-1] = 1\n    M[:-1, -1] = np.array(sequence, dtype=float)\n    M[-1, -1] = S\n</code></pre>"},{"location":"api/modules/lattice/#src.lbpqc.primitives.lattice.fullrank.babai_cvp","title":"<code>babai_cvp(arbitrary_vector, lattice_basis)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/lattice/fullrank.py</code> <pre><code>@enforce_type_check\ndef babai_cvp(arbitrary_vector: Vector, lattice_basis: SquareMatrix) -&gt; VectorInt:\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    return np.rint(arbitrary_vector @ np.linalg.inv(lattice_basis)).astype(int)\n</code></pre>"},{"location":"api/modules/lattice/#src.lbpqc.primitives.lattice.fullrank.dual_basis","title":"<code>dual_basis(lattice_basis)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/lattice/fullrank.py</code> <pre><code>@enforce_type_check\ndef dual_basis(lattice_basis: SquareMatrix) -&gt; SquareMatrix:\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    return np.linalg.inv(lattice_basis.T)\n</code></pre>"},{"location":"api/modules/lattice/#src.lbpqc.primitives.lattice.fullrank.gaussian_expected_shortest_length","title":"<code>gaussian_expected_shortest_length(lattice_basis)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/lattice/fullrank.py</code> <pre><code>@enforce_type_check\ndef gaussian_expected_shortest_length(lattice_basis: SquareMatrix) -&gt; float:\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    n = rank(lattice_basis)\n    return np.sqrt(n / (2 * np.pi * np.e)) * (volume(lattice_basis) ** (1/n))\n</code></pre>"},{"location":"api/modules/lattice/#src.lbpqc.primitives.lattice.fullrank.hadamard_ratio","title":"<code>hadamard_ratio(lattice_basis)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/lattice/fullrank.py</code> <pre><code>@enforce_type_check\ndef hadamard_ratio(lattice_basis: SquareMatrix) -&gt; float:\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    return (volume(lattice_basis) / np.linalg.norm(lattice_basis, axis=1).prod()) ** (1/rank(lattice_basis))\n</code></pre>"},{"location":"api/modules/lattice/#src.lbpqc.primitives.lattice.fullrank.rank","title":"<code>rank(lattice_basis)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/lattice/fullrank.py</code> <pre><code>@enforce_type_check\ndef rank(lattice_basis: SquareMatrix) -&gt; int:\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    return lattice_basis.shape[0]\n</code></pre>"},{"location":"api/modules/lattice/#src.lbpqc.primitives.lattice.fullrank.transition_matrix","title":"<code>transition_matrix(from_basis, to_basis)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/lattice/fullrank.py</code> <pre><code>@enforce_type_check\ndef transition_matrix(from_basis: SquareMatrix, to_basis: SquareMatrix) -&gt; SquareMatrixInt:\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    return np.rint(to_basis @ np.linalg.inv(from_basis)).astype(int)\n</code></pre>"},{"location":"api/modules/lattice/#src.lbpqc.primitives.lattice.fullrank.volume","title":"<code>volume(lattice_basis)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/lattice/fullrank.py</code> <pre><code>@enforce_type_check\ndef volume(lattice_basis: SquareMatrix) -&gt; float:\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    return abs(np.linalg.det(lattice_basis))\n</code></pre>"},{"location":"api/modules/lattice/#src.lbpqc.primitives.lattice.reductions.GLR_2dim","title":"<code>GLR_2dim(lattice_basis)</code>","text":"<p>Gaussian Lattice reduction in dimension 2</p> <p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/lattice/reductions.py</code> <pre><code>def GLR_2dim(lattice_basis: SquareMatrix) -&gt; SquareMatrixFloat:\n    '''\n    Gaussian Lattice reduction in dimension 2\n\n    Args:\n\n    Returns:\n\n    '''\n    if lattice_basis.shape != (2,2):\n        raise ValueError(f\"Lattice has to have rank 2 for gaussian reduction\")\n\n    w1 = lattice_basis[0]\n    w2 = lattice_basis[1]\n\n    v1 = w1.astype(float)\n    v2 = w2.astype(float)\n    if np.linalg.norm(v1) &gt; np.linalg.norm(v2):\n        v1, v2 = v2, v1\n\n    while np.linalg.norm(v2) &gt; np.linalg.norm(v1):\n        m = round(np.dot(v1, v2) / np.dot(v1, v1))\n        if m == 0:\n            return v1, v2\n        v2 = v2 - m * v1\n        if np.linalg.norm(v1) &gt; np.linalg.norm(v2):\n            v1, v2 = v2, v1\n\n    return np.array([v1, v2])\n</code></pre>"},{"location":"api/modules/lattice/#src.lbpqc.primitives.lattice.reductions.GSO","title":"<code>GSO(B)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/lattice/reductions.py</code> <pre><code>@enforce_type_check\ndef GSO(B: Matrix) -&gt; Tuple[MatrixFloat, SquareMatrixFloat]:\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    m, n = B.shape\n    proj_coeff = lambda q, b: np.dot(b, q) / np.dot(q, q)\n    B_star = B.astype(float)\n    U = np.identity(m)\n\n    for j in range(1, m):\n        b = B_star[j].copy()\n        for i in range(j):\n            U[i,j] = proj_coeff(B_star[i], b)\n            B_star[j] -= U[i][j] * B_star[i]\n\n    # B = U.T @ B_star\n    return B_star, U\n</code></pre>"},{"location":"api/modules/lattice/#src.lbpqc.primitives.lattice.reductions.LLL","title":"<code>LLL(lattice_basis, delta=0.75)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/lattice/reductions.py</code> <pre><code>def LLL(lattice_basis: SquareMatrix, delta: float = 0.75) -&gt; SquareMatrixFloat:\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    n = lattice_basis.shape[0]\n    B = lattice_basis.astype(float)\n    while True:\n        Bstar, _ = GSO(B)\n        # Reduction Step\n        for i in range(1, n):\n            for j in range(i-1, -1, -1):\n                cij = round(np.dot(B[i], Bstar[j]) / np.dot(Bstar[j], Bstar[j]))\n                B[i] = B[i] - cij * B[j]\n        # Swap step\n        exists = False\n        for i in range(n - 1):\n            u = np.dot(B[i + 1], Bstar[i]) / np.dot(Bstar[i], Bstar[i])\n            r = u * Bstar[i] + Bstar[i + 1]\n            if delta * np.dot(Bstar[i], Bstar[i]) &gt; np.dot(r, r):\n                B[[i, i + 1]] = B[[i + 1, i]]\n                exists = True\n                break\n        if not exists:\n            break\n    return B\n</code></pre>"},{"location":"api/modules/lattice/#src.lbpqc.primitives.lattice.reductions.babai_nearest_plane","title":"<code>babai_nearest_plane(lattice_basis, w)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/lattice/reductions.py</code> <pre><code>def babai_nearest_plane(lattice_basis: SquareMatrix, w: VectorFloat):\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    n = lattice_basis.shape[0]\n    B = LLL(lattice_basis, 0.75)\n    b = w.astype(float)\n    for j in range(n - 1, -1, -1):\n        Bstar, _ = GSO(B)\n        cj = round(np.dot(b, Bstar[j]) / np.dot(Bstar[j], Bstar[j]))\n        b = b - cj * B[j]\n    return w - b\n</code></pre>"},{"location":"api/modules/lattice/#src.lbpqc.primitives.lattice.reductions.is_LLL_reduced","title":"<code>is_LLL_reduced(lattice_basis, delta)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/lattice/reductions.py</code> <pre><code>def is_LLL_reduced(lattice_basis: Matrix, delta: float):\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    return is_size_reduced(lattice_basis) and lovasz_condition(lattice_basis, delta)\n</code></pre>"},{"location":"api/modules/lattice/#src.lbpqc.primitives.lattice.reductions.is_size_reduced","title":"<code>is_size_reduced(lattice_basis)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/lattice/reductions.py</code> <pre><code>def is_size_reduced(lattice_basis: Matrix) -&gt; bool:\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    _, U = GSO(lattice_basis)\n    return np.all(np.abs(U[np.fromfunction(lambda i, j: i &lt; j, U.shape).nonzero()]) &lt;= 0.5)\n</code></pre>"},{"location":"api/modules/lattice/#src.lbpqc.primitives.lattice.reductions.lovasz_condition","title":"<code>lovasz_condition(lattice_basis, delta)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/lattice/reductions.py</code> <pre><code>def lovasz_condition(lattice_basis: Matrix, delta: float) -&gt; bool:\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    norm2 = lambda x: np.sum(x * x, axis=1)\n    G, U = GSO(lattice_basis)\n    lhs = delta * norm2(G[:-1])\n    rhs = norm2(G[1:] + np.diag(U, 1)[:, np.newaxis] * G[:-1])\n    return np.all(lhs &lt;= rhs)\n</code></pre>"},{"location":"api/modules/matrix/","title":"Matrix","text":""},{"location":"api/modules/matrix/#src.lbpqc.primitives.matrix.HNF","title":"<code>HNF(A)</code>","text":"<p>Computes row-style Hermite Normal Form of a integer matrix A.</p> <p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/matrix.py</code> <pre><code>def HNF(A: MatrixInt) -&gt; Tuple[MatrixInt, SquareMatrixInt, int]:\n    r'''\n    Computes row-style Hermite Normal Form of a integer matrix A.\n\n    Args:\n\n    Returns:\n\n    '''\n    H = A.copy()\n    m, n = H.shape\n    p = min(m,n)\n    k, j = 0, 0\n\n    U = np.identity(m, dtype=int)\n    detU = 1\n\n\n    while j != p:\n        # Choose pivot\n        col = H[k:, j]\n        non_zero = col[col != 0]\n        if len(non_zero) == 0:\n            j += 1\n            k += 1\n            continue\n        min_val = np.min(np.abs(non_zero))\n        i0 = np.where(np.abs(col) == min_val)[0][0] + k\n        if i0 &gt; k:\n            H[[k, i0]] = H[[i0, k]]\n            detU *= -1\n            U = elementary_row_swap(m, k, i0) @ U\n\n        if H[k,j] &lt; 0:\n            H[k] = -H[k]\n            detU *= -1\n            U = elementary_row_mul(m, k, -1) @ U\n\n        # Reduce Rows\n        b = H[k,j]\n        for i in range(k+1, m):\n            q = round(H[i,j] / b)\n            H[i] -= q * H[k]\n            U = elementary_row_add(m, i, k, -q) @ U\n\n        # Check if column is done\n        if np.all(H[k+1:, j] == 0):\n            j += 1\n            k += 1\n\n    # Final reductions\n    k = 0\n    for j in range(p):\n        if H[k,j] &lt; 0:\n            H[k] = -H[k]\n            U = elementary_row_mul(m, k, -1) @ U\n            detU *= -1\n\n        b = H[k,j]\n        if b == 0: continue\n        for i in range(k):\n            q = H[i,j] // b\n            H[i] -= q * H[k]\n            U = elementary_row_add(m, i, k, -q) @ U\n\n        k += 1\n\n    return H, U, detU\n</code></pre>"},{"location":"api/modules/matrix/#src.lbpqc.primitives.matrix.cofactor","title":"<code>cofactor(A, i, j)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/matrix.py</code> <pre><code>def cofactor(A: SquareMatrixInt, i: int, j: int) -&gt; int:\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    return minor(A, i, j) * ((-1) ** (i + 1 + j + 1))\n</code></pre>"},{"location":"api/modules/matrix/#src.lbpqc.primitives.matrix.cofactor_matrix","title":"<code>cofactor_matrix(A)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/matrix.py</code> <pre><code>def cofactor_matrix(A: SquareMatrixInt) -&gt; SquareMatrixInt:\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    n = A.shape[0]\n    C = np.zeros((n,n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            C[i,j] = cofactor(A, i, j)\n    return C\n</code></pre>"},{"location":"api/modules/matrix/#src.lbpqc.primitives.matrix.det","title":"<code>det(A)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/matrix.py</code> <pre><code>def det(A: SquareMatrixInt) -&gt; int:\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    H, U, detU = HNF(A)\n    return np.prod(np.diagonal(H)) * detU\n</code></pre>"},{"location":"api/modules/matrix/#src.lbpqc.primitives.matrix.dual_q_ary_lattice_basis","title":"<code>dual_q_ary_lattice_basis(A, modulus)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/matrix.py</code> <pre><code>def dual_q_ary_lattice_basis(A: MatrixInt, modulus: int) -&gt; SquareMatrixModInt:\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    m, n = A.shape\n    Y = mod_left_kernel(A, modulus)\n    assert Y.shape == (m - n, m)\n\n    q = modulus\n    return np.block([[Y], [np.zeros((m-n, m-n), dtype=int), q * np.identity(n, dtype=int)]])\n</code></pre>"},{"location":"api/modules/matrix/#src.lbpqc.primitives.matrix.elementary_row_add","title":"<code>elementary_row_add(n, i, j, s)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/matrix.py</code> <pre><code>def elementary_row_add(n: int, i: int, j: int, s: int):\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    E = np.identity(n, int)\n    E[i, j] = s\n    return E\n</code></pre>"},{"location":"api/modules/matrix/#src.lbpqc.primitives.matrix.elementary_row_mul","title":"<code>elementary_row_mul(n, i, s)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/matrix.py</code> <pre><code>def elementary_row_mul(n: int, i: int, s: int):\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    E = np.identity(n, int)\n    E[i, i] = s\n    return E\n</code></pre>"},{"location":"api/modules/matrix/#src.lbpqc.primitives.matrix.elementary_row_swap","title":"<code>elementary_row_swap(n, i, j)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/matrix.py</code> <pre><code>def elementary_row_swap(n: int, i: int, j: int):\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    E = np.identity(n, int)\n    E[[i,j]] = E[[j, i]]\n    return E\n</code></pre>"},{"location":"api/modules/matrix/#src.lbpqc.primitives.matrix.left_kernel","title":"<code>left_kernel(A)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/matrix.py</code> <pre><code>def left_kernel(A: MatrixInt) -&gt; MatrixInt|None:\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    H, U, _ = HNF(A)\n    r = 0\n    for row in H[::-1]:\n        if np.all(row == 0):\n            r += 1\n        else:\n            break\n    if r == 0:\n        return None\n    return U[-r::]\n</code></pre>"},{"location":"api/modules/matrix/#src.lbpqc.primitives.matrix.matrix_modinv","title":"<code>matrix_modinv(A, modulus)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/matrix.py</code> <pre><code>def matrix_modinv(A: SquareMatrixInt, modulus: int) -&gt; SquareMatrixModInt:\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    C = cofactor_matrix(A) % modulus\n    det_inv = integer_ring.modinv(det(A), modulus)\n\n    return (det_inv * C.T) % modulus\n</code></pre>"},{"location":"api/modules/matrix/#src.lbpqc.primitives.matrix.minor","title":"<code>minor(A, i, j)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/matrix.py</code> <pre><code>def minor(A: SquareMatrixInt, i: int, j: int) -&gt; int:\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    return det(np.delete(np.delete(A, i, axis=0), j, axis=1))\n</code></pre>"},{"location":"api/modules/matrix/#src.lbpqc.primitives.matrix.mod_REF","title":"<code>mod_REF(A, modulus)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/matrix.py</code> <pre><code>def mod_REF(A: MatrixInt, modulus: int) -&gt; Tuple[MatrixModInt, SquareMatrixModInt]:\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    m, n = A.shape\n    inv = lambda a: integer_ring.modinv(a, modulus)\n\n    M = A.copy()\n    M %= modulus\n\n    U = np.identity(m, dtype=int)\n\n    for j in range(min(m,n)):\n        #print(f\"j= {j}\")\n        #print(M)\n        col = M[ : ,j]\n        nonzero = np.nonzero(col[j:])[0]\n        if len(nonzero) == 0:\n            # no pivot, in this column\n            continue\n        pivot_i = nonzero[0] + j\n\n        #print(\"current column:\")\n        #print(col)\n        #print(f\"pivot index: {pivot_i}\")\n        #print(f\"pivot value: {M[pivot_i, j]}\")\n\n\n        if pivot_i != j:\n            row_swap(M, pivot_i, j)\n            U = (elementary_row_swap(m, pivot_i, j) @ U) % modulus\n\n        #print(\"After swap\")\n        #print(M)\n\n\n        pivot_inv = inv(M[j,j])\n        row_scale(M, j, pivot_inv)\n        U = (elementary_row_mul(m, j, pivot_inv) @ U) % modulus\n\n        M %= modulus\n\n        #print(\"After scale\")\n        #print(M)\n\n\n        for i in range(j + 1, m):\n            if M[i, j] != 0:\n                U = (elementary_row_add(m, i, j, -M[i,j]) @ U) % modulus\n                row_add(M, i, j, -M[i,j])\n                M %= modulus\n\n        #print(\"After reduce\")\n        #print(M)\n        #print(\"===============\")\n\n    return M % modulus, U % modulus\n</code></pre>"},{"location":"api/modules/matrix/#src.lbpqc.primitives.matrix.mod_RREF","title":"<code>mod_RREF(A, modulus)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/matrix.py</code> <pre><code>def mod_RREF(A: MatrixInt, modulus: int) -&gt; Tuple[MatrixModInt, SquareMatrixModInt]:\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    M, U = mod_REF(A, modulus)\n    m, n = M.shape\n\n    h = m - 1\n    for j in range(n - 1, -1, -1):\n        # check if current column is a pivot column\n        if M[h, j] != 1:\n            # skip zero rows at the bottom\n            if M[h, j] == 0:\n                h -= 1\n            continue\n\n        # reduce column's entries below pivot\n        for i in range(h - 1, -1, -1):\n            coeff = M[i,j]\n            row_add(M, i, h, -coeff)\n            U = elementary_row_add(m, i, h, -coeff) @ U\n\n        # move to the next row\n        h -= 1\n\n\n    return M % modulus, U % modulus\n</code></pre>"},{"location":"api/modules/matrix/#src.lbpqc.primitives.matrix.mod_left_kernel","title":"<code>mod_left_kernel(A, modulus)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/matrix.py</code> <pre><code>def mod_left_kernel(A: MatrixInt, modulus: int) -&gt; MatrixInt|None:\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    G, U = mod_RREF(A, modulus)\n    r = 0\n    for row in G[::-1]:\n        if np.all(row == 0):\n            r += 1\n        else:\n            break\n    if r == 0:\n        return None\n    return U[-r::]\n</code></pre>"},{"location":"api/modules/matrix/#src.lbpqc.primitives.matrix.nullity","title":"<code>nullity(A)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/matrix.py</code> <pre><code>def nullity(A: MatrixInt) -&gt; int:\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    H, U, _ = HNF(A)\n    r = 0\n    for row in H[::-1]:\n        if np.all(row == 0):\n            r += 1\n        else:\n            break\n    return r\n</code></pre>"},{"location":"api/modules/matrix/#src.lbpqc.primitives.matrix.q_ary_lattice_basis","title":"<code>q_ary_lattice_basis(A, modulus)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/matrix.py</code> <pre><code>def q_ary_lattice_basis(A: MatrixInt, modulus: int) -&gt; SquareMatrixInt:\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    m, n = A.shape\n    assert n &gt;= m\n    # A = (A1 | A2)\n    A1 = A[ : ,:m] # m x m\n    A2 = A[ : ,m:] # m x (n - m)\n\n    B11 = np.identity(m, dtype=int) # m x m\n    B12 = (matrix_modinv(A1, modulus) @ A2) % modulus # m x (n - m)\n    B21 = np.zeros((n - m, m), dtype=int)\n    B22 = modulus * np.identity(n - m, dtype=int)\n\n    print(B11)\n    print()\n    print(B12)\n    print()\n    print(B21)\n    print()\n    print(B22)\n\n    return np.block([[B11, B12], [B21, B22]])\n</code></pre>"},{"location":"api/modules/matrix/#src.lbpqc.primitives.matrix.row_add","title":"<code>row_add(M, i, k, s)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/matrix.py</code> <pre><code>def row_add(M: MatrixInt, i: int, k: int, s: int):\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    M[i] += s * M[k]\n</code></pre>"},{"location":"api/modules/matrix/#src.lbpqc.primitives.matrix.row_scale","title":"<code>row_scale(M, i, s)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/matrix.py</code> <pre><code>def row_scale(M: MatrixInt, i: int, s: int):\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    M[i] *= s\n</code></pre>"},{"location":"api/modules/matrix/#src.lbpqc.primitives.matrix.row_swap","title":"<code>row_swap(M, i, j)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/matrix.py</code> <pre><code>def row_swap(M: MatrixInt, i: int, j: int):\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    M[[i,j]] = M[[j,i]]\n</code></pre>"},{"location":"api/modules/polynomial/","title":"Polynomial","text":"<p>This class implements operations over \\(\\mathbb{Z}_p[X]\\) polynomial ring, i.e. polynomials which coefficients are reduced modulo \\(p\\).</p> <p>It's important to note that polynomials are represented as numpy's arrays with entries corresponding to coefficients in order of increasing powers. Instance of <code>ModIntPolyRing</code> class represents the polynomials ring. It's methods implements operations in this rings, but polynomials in their inputs and outputs are still numpy's arrays.</p> <p>Attributes:</p> Name Type Description <code>modulus</code> <code>int</code> <p>modulus \\(p\\) of the \\(\\mathbb{Z}_p[X]\\) polynomial ring.</p> Source code in <code>src/lbpqc/primitives/polynomial/modpoly.py</code> <pre><code>class ModIntPolyRing:\n    r'''This class implements operations over $\\mathbb{Z}_p[X]$ polynomial ring, i.e. polynomials which coefficients are reduced modulo $p$.\n\n    It's important to note that polynomials are represented as numpy's arrays with entries corresponding to coefficients in order of increasing powers.  \n    Instance of `ModIntPolyRing` class represents the polynomials ring.  \n    It's methods implements operations in this rings, but polynomials in their inputs and outputs are still numpy's arrays.\n\n    Attributes:\n        modulus (int): modulus $p$ of the $\\mathbb{Z}_p[X]$ polynomial ring.\n    '''\n    @enforce_type_check\n    def __init__(self, modulus: int) -&gt; None:\n        r'''\n        Constructs the ring object for a given **modulus**.\n\n        Args:\n            modulus: Ring modulus.\n        '''\n        if modulus &lt;= 1: raise ValueError(\"Modulus has to be greater than 1\")\n        self.modulus = modulus\n\n\n    @enforce_type_check\n    def reduce(self, polynomial: VectorInt) -&gt; VectorModInt:\n        r'''\n        Reduces the given polynomial to it's cannonical equivalence class in the ring, i.e. reduces polynomials' coefficients modulo **modulus**.\n\n        Args:\n            polynomial: Polynomial's coefficients array.\n\n        Returns:\n            Array of coefficients reduced modulo **modulus**.\n        '''\n        return poly.trim(polynomial % self.modulus)\n\n\n    @enforce_type_check\n    def is_zero(self, polynomial: VectorInt) -&gt; bool:\n        r'''\n        Checks whether given polynomial is zero polynomial in the ring,\n        so whether all it's coefficients are divisible by **modulus**.\n\n        Args:\n            polynomial: Coefficients array of polynomial to be checked.\n\n        Returns:\n            `True` if polynomial is zero polynomial in the ring else `False`\n        '''\n        return poly.is_zero_poly(self.reduce(polynomial))\n\n\n    @enforce_type_check\n    def deg(self, polynomial: VectorInt) -&gt; int:\n        r'''Calculates degree of the given polynomial.\n\n        Args:\n            polynomial: polynomial's coefficients\n\n        Returns:\n            degree of the polynomial in the ring.\n        '''\n\n        return poly.deg(self.reduce(polynomial))\n\n\n    @enforce_type_check\n    def add(self, polynomial_a: VectorInt, polynomial_b: VectorInt) -&gt; VectorModInt:\n        r'''Adds polynomial $a$ to polynomial $b$.\n\n        Args:\n            polynomial_a: polynomial's $a$ coefficients.\n            polynomial_b: polynomial's $b$ coefficients.\n\n        Returns:\n            Coefficients array of polynomial $a + b$.\n        '''\n\n        return self.reduce(poly.add(polynomial_a, polynomial_b))\n\n    @enforce_type_check\n    def sub(self, polynomial_a: VectorInt, polynomial_b: VectorInt) -&gt; VectorModInt:\n        r'''Subtract polynomial $b$ from polynomial $a$.\n\n        Args:\n            polynomial_a: polynomial's $a$ coefficients.\n            polynomial_b: polynomial's $b$ coefficients.\n\n        Returns:\n            Coefficients array of polynomial $a - b$.\n        '''\n\n\n        return self.reduce(poly.sub(polynomial_a, polynomial_b))\n\n\n    @enforce_type_check\n    def mul(self, polynomial_a: VectorInt, polynomial_b: VectorInt) -&gt; VectorModInt:\n        r'''Multiplies polynomial $a$ and polynomial $b$.\n\n        Args:\n            polynomial_a: polynomial's $a$ coefficients.\n            polynomial_b: polynomial's $b$ coefficients.\n\n        Returns:\n            Coefficients array of polynomial $a \\cdot b$.\n        '''\n\n        return self.reduce(poly.mul(polynomial_a, polynomial_b))\n\n\n    @enforce_type_check\n    def euclidean_div(self,  polynomial_a: VectorInt, polynomial_b: VectorInt) -&gt; Tuple[VectorModInt, VectorModInt]:\n        r'''Euclidean division (long division) for polynomials in the ring.\n\n        Args:\n            polynomial_a: .\n            polynomial_b: .\n\n        Returns:\n            Quotient and Remainder polynomials.\n        '''\n\n        if self.is_zero(polynomial_b): raise ZeroDivisionError(\"Can't divide by zero polynomial\")\n\n        q = poly.zero_poly()\n        r = self.reduce(polynomial_a)\n\n        d = self.deg(polynomial_b)\n        c = polynomial_b[d]\n        while (dr := self.deg(r)) &gt;= d:\n            s = poly.monomial(r[dr] * modinv(c, self.modulus), dr - d)\n            q = self.add(q, s)\n            r = self.sub(r, self.mul(s, polynomial_b))\n\n        return q, r\n\n\n    @enforce_type_check\n    def rem(self, polynomial_a: VectorInt, polynomial_b: VectorInt) -&gt; VectorModInt:\n        r'''Computes only remainder of the euclidean divions of two ring's polynomials.\n\n        Args:\n            polynomial_a: .\n            polynomial_b: .\n\n        Returns:\n            Remainder of the euclidean division.\n        '''\n\n        if self.is_zero(polynomial_b): raise ZeroDivisionError(\"Can't divide by zero polynomial\")\n\n        _, r = self.euclidean_div(polynomial_a, polynomial_b)\n        return r\n\n    @enforce_type_check\n    def to_monic(self, polynomial: VectorInt) -&gt; VectorModInt:\n        r'''Reduces given polynomial to monic polynomial by multiplying it by scalar equal to modular multiplicative inverse of the highest power coefficient.\n\n        Args:\n            polynomial: .\n\n        Returns:\n            Polynomial with leading coefficient equal to 1.\n        '''\n\n        leading_coeff = polynomial[self.deg(polynomial)]\n\n        return self.reduce(modinv(leading_coeff, self.modulus) * polynomial)\n\n\n    @enforce_type_check\n    def gcd(self, polynomial_a: VectorInt, polynomial_b: VectorInt) -&gt; VectorModInt:\n        r'''calculates $\\gcd$ of polynomials $a$ and $b$ using euclidean algorithm.  \n        It's worth noting that int the polynomial ring, $\\gcd$ is not unique.\n\n        Args:\n            polynomial_a: Coefficients array of polynomial $a$.\n            polynomial_b: Coefficients array of polynomial $b$.\n\n        Returns:\n            Polynomial with maximal degree that divides both $a$ and $b$.\n\n        '''\n\n        r0 = self.reduce(polynomial_a)\n        r1 = self.reduce(polynomial_b)\n        if poly.deg(r1) &gt; poly.deg(r0):\n            r0, r1 = r1, r0\n\n        while not self.is_zero(r1):\n            r0, r1 = r1, self.rem(r0, r1)\n\n        return r0\n\n\n    @enforce_type_check\n    def coprime(self, polynomial_a: VectorInt, polynomial_b: VectorInt) -&gt; bool:\n        r'''checks whether two polynomials $a$ and $b$ are coprime in a ring.  \n        Checks whether $\\gcd(a,b)$ reduced to monic polynomial is equal to constant polynomial $p \\equiv 1$.\n\n        Args:\n            polynomial_a: Coefficients array of polynomial $a$.\n            polynomial_b: Coefficients array of polynomial $b$.\n\n        Returns:\n            `True` if $a$ and $b$ are coprime in the ring, `False` otherwise.\n\n        '''\n        return np.all(self.to_monic(self.gcd(polynomial_a, polynomial_b)) == poly.monomial(1, 0))\n\n\n    @enforce_type_check\n    def eea(self, polynomial_a: VectorInt, polynomial_b: VectorInt) -&gt; Tuple[VectorModInt, VectorModInt, VectorModInt]:\n        r'''Extended Euclidean algorithm for polynomials, e.i algorithm that calculates coefficients for **B\u00e9zout's identity**.\n\n        Args:\n            polynomial_a: Coefficients array of polynomial $a$.\n            polynomial_b: Coefficients array of polynomial $b$.\n\n        Returns:\n            Tuple of polynomials $(d, s, t)$ that satisfies $\\gcd(a,b) = d$ and $s \\cdot a + t \\cdot b = d$.\n\n        '''\n\n        f0, f1 = self.reduce(polynomial_a), self.reduce(polynomial_b)\n        a0, a1 = poly.monomial(1, 0), poly.zero_poly()\n        b0, b1 = poly.zero_poly(), poly.monomial(1, 0)\n\n        while not self.is_zero(f1):\n            q, r = self.euclidean_div(f0, f1)\n\n            f0, f1 = f1, r\n\n            a0, a1 = a1, self.sub(a0, self.mul(q, a1))\n            b0, b1 = b1, self.sub(b0, self.mul(q, b1))\n\n        return f0, a0, b0\n</code></pre> <p>This class implements operations over polynomial quotient ring $$ \\frac{\\mathbb{Z}_p[X]}{q(X)} $$ for given positive integer \\(p\\) and polynomial \\(q\\).</p> <p>It's important to note that polynomials are represented as numpy's arrays with entries corresponding to coefficients in order of increasing powers. Instance of <code>PolyQuotientRing</code> class represents the polynomials ring. It's methods implements operations in this rings, but polynomials in their inputs and outputs are still numpy's arrays.</p> <p>Attributes:</p> Name Type Description <code>poly_modulus</code> <code>VectorInt</code> <p>.</p> <code>int_modulus</code> <code>int</code> <p>.</p> <code>Zm</code> <code>ModIntPolyRing</code> <p>Object representing \\(\\mathbb{Z}_p\\) ring.</p> Source code in <code>src/lbpqc/primitives/polynomial/polyqring.py</code> <pre><code>class PolyQuotientRing:\n    r'''This class implements operations over polynomial quotient ring\n    $$\n    \\frac{\\mathbb{Z}_p[X]}{q(X)}\n    $$\n    for given positive integer $p$ and polynomial $q$.\n\n    It's important to note that polynomials are represented as numpy's arrays with entries corresponding to coefficients in order of increasing powers.  \n    Instance of `PolyQuotientRing` class represents the polynomials ring.  \n    It's methods implements operations in this rings, but polynomials in their inputs and outputs are still numpy's arrays.\n\n    Attributes:\n        poly_modulus (VectorInt): .\n        int_modulus (int): .\n        Zm (ModIntPolyRing): Object representing $\\mathbb{Z}_p$ ring.\n    '''\n    @enforce_type_check\n    def __init__(self, poly_modulus: VectorInt, int_modulus: int) -&gt; None:\n        r'''Constructs the ring object for a given polynomial modulus and integer modulus.\n\n        Args:\n            poly_modulus: Coefficients array of polynomial modulus fot the ring. The $q(X)$ in $\\frac{\\mathbb{Z}_p[X]}{q(X)}$.\n            int_modulus: Integer modulus for the ring. The $p$ in $\\frac{\\mathbb{Z}_p[X]}{q(X)}$.\n        '''\n        self.poly_modulus = poly_modulus\n        self.int_modulus = int_modulus\n        self.Zm = modpoly.ModIntPolyRing(int_modulus)\n\n\n    @property\n    def quotient(self):\n        return self.poly_modulus\n\n\n    @enforce_type_check\n    def reduce(self, polynomial: VectorInt) -&gt; VectorModInt:\n        r'''Reduces the given polynomial $u$ to it's cannonical equivalence class in the ring,\n        i.e. takes, the remainder of division $\\frac{u}{q}$, where $q$ is polynomial modulus for the ring.  \n        The division is performed in $\\mathbb{Z}_p[X]$ ring.\n\n        Args:\n            polynomial: Polynomial's coefficients array.\n\n        Returns:\n            Coefficients array of polynomial that is the remainder of the Euclidean division.\n        '''\n        return self.Zm.rem(polynomial, self.poly_modulus)\n\n\n    @enforce_type_check\n    def add(self, polynomial_a: VectorInt, polynomial_b: VectorInt) -&gt; VectorModInt:\n        r'''Adds polynomial $a$ to polynomial $b$.\n\n        Args:\n            polynomial_a: polynomial's $a$ coefficients.\n            polynomial_b: polynomial's $b$ coefficients.\n\n        Returns:\n            Coefficients array of polynomial $a + b$.\n        '''\n\n        return self.reduce(self.Zm.add(polynomial_a, polynomial_b))\n\n\n    @enforce_type_check\n    def sub(self, polynomial_a: VectorInt, polynomial_b: VectorInt) -&gt; VectorModInt:\n        r'''Subtract polynomial $b$ from polynomial $a$.\n\n        Args:\n            polynomial_a: polynomial's $a$ coefficients.\n            polynomial_b: polynomial's $b$ coefficients.\n\n        Returns:\n            Coefficients array of polynomial $a - b$.\n        '''\n\n        return self.reduce(self.Zm.sub(polynomial_a, polynomial_b))\n\n    @enforce_type_check\n    def mul(self, polynomial_a: VectorInt, polynomial_b: VectorInt) -&gt; VectorModInt:\n        r'''Multiplies polynomial $a$ and polynomial $b$.\n\n        Args:\n            polynomial_a: polynomial's $a$ coefficients.\n            polynomial_b: polynomial's $b$ coefficients.\n\n        Returns:\n            Coefficients array of polynomial $a \\cdot b$.\n        '''\n\n        return self.reduce(self.Zm.mul(polynomial_a, polynomial_b))\n\n    @enforce_type_check\n    def inv(self, polynomial: VectorInt) -&gt; VectorModInt:\n        r'''For a given polynomial $v$, calculates it's multiplicative inverse in a ring.\n\n        Args:\n            polynomial: Polynomial's coefficients array.\n\n        Returns:\n            Coefficients array of polynomial $u$, such that $u \\cdot v \\equiv 1$.\n\n        Raises:\n            ValueError: When given polynomial is not an unit in the ring (it's not coprime with ring's polynomial modulus).\n\n        '''\n\n        if not self.Zm.coprime(polynomial, self.poly_modulus): raise ValueError(\"Inverse does not exists\")\n\n        gcd, u, _ = self.Zm.eea(polynomial, self.poly_modulus)\n\n        c = integer_ring.modinv(gcd, self.int_modulus)\n\n        return self.reduce(u * c)\n</code></pre> <p>Function for constructing commonly used quotient rings.</p> <p>Possible optinos:     - \"-\" || \"X^N - 1\": represents \\(X^N - 1\\) polynomial family.     - \"+\" || \"X^N + 1\": represents \\(X^N + 1\\) polynomial family.     - \"prime\" || \"X^N - x - 1\": represents \\(X^N - X - 1\\) polynomial family.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>str</code> <p>string representation/symbol of ring's polynomial modulus.</p> required <code>N</code> <code>int</code> <p>Degree of the polynomial modulus of the ring.</p> required <code>q</code> <code>int</code> <p>Integer modulus of the ring.</p> required <p>Returns:</p> Type Description <code>PolyQuotientRing | None</code> <p>None if the parameters were invalid else ring object.</p> Source code in <code>src/lbpqc/primitives/polynomial/polyqring.py</code> <pre><code>def construct_ring(p: str, N: int, q: int) -&gt; PolyQuotientRing|None:\n    r'''Function for constructing commonly used quotient rings.\n\n     Possible optinos:  \n        - \"-\" || \"X^N - 1\": represents $X^N - 1$ polynomial family.  \n        - \"+\" || \"X^N + 1\": represents $X^N + 1$ polynomial family.  \n        - \"prime\" || \"X^N - x - 1\": represents $X^N - X - 1$ polynomial family.\n\n\n    Args:\n        p: string representation/symbol of ring's polynomial modulus.\n        N: Degree of the polynomial modulus of the ring.\n        q: Integer modulus of the ring.\n\n    Returns:\n        None if the parameters were invalid else ring object.\n    '''\n    g = poly.zero_poly(N)\n    match p:\n        case \"-\" | \"X^N - 1\":\n            g[[0, N]] =-1, 1\n            pass\n        case \"+\" | \"X^N + 1\":\n            g[[0, N]] = 1, 1\n            pass\n        case \"prime\" | \"X^N - x - 1\":\n            g[[0, 1, N]] = -1, -1, 1\n        case _:\n            return None\n\n    return PolyQuotientRing(g, q)\n</code></pre>"},{"location":"api/modules/polynomial/#src.lbpqc.primitives.polynomial.poly.add","title":"<code>add(p, q)</code>","text":"<p>Adds two polynomials.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>VectorInt</code> <p>polynomial's \\(p\\) coefficients.</p> required <code>q</code> <code>VectorInt</code> <p>polynomial's \\(q\\) coefficients.</p> required <p>Returns:</p> Type Description <code>VectorInt</code> <p>Coefficients array of polynomial \\(p + q\\).</p> Source code in <code>src/lbpqc/primitives/polynomial/poly.py</code> <pre><code>@enforce_type_check\ndef add(p: VectorInt, q: VectorInt) -&gt; VectorInt:\n    r'''Adds two polynomials.\n\n    Args:\n        p: polynomial's $p$ coefficients.\n        q: polynomial's $q$ coefficients.\n\n    Returns:\n        Coefficients array of polynomial $p + q$.\n    '''\n\n    max_deg = max(deg(p), deg(q), 0)\n    return trim(pad(p, max_deg) + pad(q, max_deg))\n</code></pre>"},{"location":"api/modules/polynomial/#src.lbpqc.primitives.polynomial.poly.deg","title":"<code>deg(p, *, error_if_zero_poly=False)</code>","text":"<p>Returns degree of a given polynomial calculated as an index of the last nonzero ceofficient. Returns -1 as a degree of zero polynomial if <code>error_if_zero_poly</code> is set to <code>False</code>.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>VectorInt</code> <p>Polynomial's coefficients.</p> required <code>error_if_zero_poly</code> <code>bool</code> <p>Parameter deciding how to treat degree of zero polynomial.</p> <code>False</code> <p>Returns:</p> Type Description <code>int</code> <p>Degree of the given polynomial.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If given empty numpy array.</p> <code>ValueError</code> <p>If given zero polynomial and error_if_zero_poly is set to True.</p> Source code in <code>src/lbpqc/primitives/polynomial/poly.py</code> <pre><code>@enforce_type_check\ndef deg(p: VectorInt,*, error_if_zero_poly: bool = False) -&gt; int:\n    r'''\n    Returns degree of a given polynomial calculated as an index of the last nonzero ceofficient.\n    Returns -1 as a degree of zero polynomial if `error_if_zero_poly` is set to `False`.\n\n    Args:\n        p: Polynomial's coefficients.\n        error_if_zero_poly: Parameter deciding how to treat degree of zero polynomial.\n\n    Returns:\n        Degree of the given polynomial.\n\n    Raises:\n        ValueError: If given empty numpy array.\n        ValueError: If given zero polynomial **and** error_if_zero_poly is set to True.\n    '''\n    if len(p) == 0: raise ValueError(\"degree undefined for an empty numpy array\")\n\n    if len(nonzeros := np.nonzero(p)[0]) == 0:\n        if error_if_zero_poly: raise ValueError(\"Degree of zero polynomial is undefined\")\n        return -1\n    else:\n        return nonzeros[-1]\n</code></pre>"},{"location":"api/modules/polynomial/#src.lbpqc.primitives.polynomial.poly.is_zero_poly","title":"<code>is_zero_poly(p)</code>","text":"<p>Checks if given polynomial is zero polynomial.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>VectorInt</code> <p>Polynomial's coefficients.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if \\(p \\equiv 0\\), False otherwise</p> Source code in <code>src/lbpqc/primitives/polynomial/poly.py</code> <pre><code>@enforce_type_check\ndef is_zero_poly(p: VectorInt) -&gt; bool:\n    r'''Checks if given polynomial is zero polynomial.\n\n    Args:\n        p: Polynomial's coefficients.\n\n    Returns:\n        True if $p \\equiv 0$, False otherwise\n    '''\n    if len(p) == 0: raise ValueError(\"Empty numpy array is not a proper polynomial\")\n\n    return np.count_nonzero(p) == 0\n</code></pre>"},{"location":"api/modules/polynomial/#src.lbpqc.primitives.polynomial.poly.monomial","title":"<code>monomial(coeff, degree)</code>","text":"<p>For given degree \\(d\\) and coefficient \\(c\\), constructs a monomial $$     cX^{d - 1} $$</p> <p>Parameters:</p> Name Type Description Default <code>coeff</code> <code>int</code> <p>Monomial's coefficient.</p> required <code>degree</code> <code>int</code> <p>Monomial's degree.</p> required <p>Returns:</p> Type Description <code>VectorInt</code> <p>Coefficients' array with only nonzero entry <code>coeff</code> at <code>degree</code> index.</p> <p>Examples:</p> <p>\\(7X^5\\)</p> <pre><code>&gt;&gt;&gt; monomial(7, 5)\narray([0,0,0,0,0,5])\n</code></pre> Source code in <code>src/lbpqc/primitives/polynomial/poly.py</code> <pre><code>@enforce_type_check\ndef monomial(coeff: int, degree: int) -&gt; VectorInt:\n    r'''\n    For given degree $d$ and coefficient $c$, constructs a monomial\n    $$\n        cX^{d - 1}\n    $$\n\n    Args:\n        coeff: Monomial's coefficient.\n        degree: Monomial's degree.\n\n    Returns:\n        Coefficients' array with only nonzero entry `coeff` at `degree` index.\n\n    Examples:\n        $7X^5$\n        &gt;&gt;&gt; monomial(7, 5)\n        array([0,0,0,0,0,5])\n    '''\n    p = np.zeros(degree + 1, dtype=int)\n    p[degree] = coeff\n    return p\n</code></pre>"},{"location":"api/modules/polynomial/#src.lbpqc.primitives.polynomial.poly.mul","title":"<code>mul(p, q)</code>","text":"<p>Multiplies polynomials \\(p\\) and \\(q\\).</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>Vector</code> <p>polynomial's \\(p\\) coefficients.</p> required <code>q</code> <code>Vector</code> <p>polynomial's \\(q\\) coefficients.</p> required <p>Returns:</p> Type Description <code>Vector</code> <p>Coefficients array of polynomial \\(p \\cdot q\\).</p> Source code in <code>src/lbpqc/primitives/polynomial/poly.py</code> <pre><code>@enforce_type_check\ndef mul(p: Vector, q: Vector) -&gt; Vector:\n    r'''Multiplies polynomials $p$ and $q$.\n\n    Args:\n        p: polynomial's $p$ coefficients.\n        q: polynomial's $q$ coefficients.\n\n    Returns:\n        Coefficients array of polynomial $p \\cdot q$.\n    '''\n\n    return np.polymul(p[::-1], q[::-1])[::-1]\n</code></pre>"},{"location":"api/modules/polynomial/#src.lbpqc.primitives.polynomial.poly.pad","title":"<code>pad(p, max_deg)</code>","text":"<p>Pad's polynomial's coefficient's array with zero entries for powers higher than polynomial's degree, so that length of resulting array is equal to max_deg + 1.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>VectorInt</code> <p>Polynomial's coefficients.</p> required <code>max_deg</code> <code>int</code> <p>Degree that \\(p\\) is to be expanded to.</p> required <p>Returns:</p> Type Description <code>VectorInt</code> <p>Coefficient's array with length equal to <code>max_deg</code> + 1, filled with zeros at indices greater than \\(\\deg(p)\\).</p> <p>Examples:</p> <p>\\(p = X^3 + 7X - 2\\)</p> <pre><code>&gt;&gt;&gt; p = np.array([-2, 7, 0, 1])\n&gt;&gt;&gt; pad(p, 5)\narray([-2, 7, 0, 1, 0, 0])\n</code></pre> Source code in <code>src/lbpqc/primitives/polynomial/poly.py</code> <pre><code>@enforce_type_check\ndef pad(p: VectorInt, max_deg: int) -&gt; VectorInt:\n    r'''\n    Pad's polynomial's coefficient's array with zero entries for powers higher than polynomial's degree,\n    so that length of resulting array is equal to max_deg + 1.\n\n    Args:\n        p: Polynomial's coefficients.\n        max_deg: Degree that $p$ is to be expanded to.\n\n    Returns:\n        Coefficient's array with length equal to `max_deg` + 1, filled with zeros at indices greater than $\\deg(p)$.\n\n    Examples:\n        $p = X^3 + 7X - 2$\n        &gt;&gt;&gt; p = np.array([-2, 7, 0, 1])\n        &gt;&gt;&gt; pad(p, 5)\n        array([-2, 7, 0, 1, 0, 0])\n    '''\n    if is_zero_poly(p):\n        return zero_poly(max_deg)\n\n    d = deg(p)\n    if max_deg &lt; d: raise ValueError(\"max_deg has to be greater or equal to the degree of a given polynomial p\")\n\n    return np.pad(trim(p), (0, max_deg - d))\n</code></pre>"},{"location":"api/modules/polynomial/#src.lbpqc.primitives.polynomial.poly.sub","title":"<code>sub(p, q)</code>","text":"<p>Subtract polynomial \\(q\\) from polynomial \\(p\\).</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>VectorInt</code> <p>polynomial's \\(p\\) coefficients.</p> required <code>q</code> <code>VectorInt</code> <p>polynomial's \\(q\\) coefficients.</p> required <p>Returns:</p> Type Description <code>VectorInt</code> <p>Coefficients array of polynomial \\(p - q\\).</p> Source code in <code>src/lbpqc/primitives/polynomial/poly.py</code> <pre><code>@enforce_type_check\ndef sub(p: VectorInt, q: VectorInt) -&gt; VectorInt:\n    r'''Subtract polynomial $q$ from polynomial $p$.\n\n    Args:\n        p: polynomial's $p$ coefficients.\n        q: polynomial's $q$ coefficients.\n\n    Returns:\n        Coefficients array of polynomial $p - q$.\n    '''\n\n    max_deg = max(deg(p), deg(q), 0)\n    return trim(pad(p, max_deg) - pad(q, max_deg))\n</code></pre>"},{"location":"api/modules/polynomial/#src.lbpqc.primitives.polynomial.poly.trim","title":"<code>trim(p)</code>","text":"<p>Trims zero coefficients of powers higher than polynomial's degree, so that resulting coefficient's arrray has length of \\(\\deg(p) + 1\\).</p> <p>If p is zero polynomial, then returns <code>np.array([0], dtype=int)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>VectorInt</code> <p>Polynomial's coefficients.</p> required <p>Returns:</p> Type Description <code>VectorInt</code> <p>Coefficient's array of length at most \\(\\deg(p)\\).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; p = np.array([1,0,2,3,0,0,0])\n&gt;&gt;&gt; trim(p)\narray([1,0,2,3])\n</code></pre> Source code in <code>src/lbpqc/primitives/polynomial/poly.py</code> <pre><code>@enforce_type_check\ndef trim(p: VectorInt) -&gt; VectorInt:\n    r'''\n    Trims zero coefficients of powers higher than polynomial's degree,\n    so that resulting coefficient's arrray has length of $\\deg(p) + 1$.\n\n    If p is zero polynomial, then returns `np.array([0], dtype=int)`.\n\n    Args:\n        p: Polynomial's coefficients.\n\n    Returns:\n        Coefficient's array of length at most $\\deg(p)$.\n\n    Examples:\n        &gt;&gt;&gt; p = np.array([1,0,2,3,0,0,0])\n        &gt;&gt;&gt; trim(p)\n        array([1,0,2,3])\n    '''\n    if is_zero_poly(p):\n        return np.zeros(1, dtype=int)\n\n    return p[:deg(p) + 1].copy()\n</code></pre>"},{"location":"api/modules/polynomial/#src.lbpqc.primitives.polynomial.poly.zero_poly","title":"<code>zero_poly(max_deg=0)</code>","text":"<p>Explicitly constructs zero polynomial, i.e. a coefficient's array of length <code>max_deg</code> + 1 filled with zeros.</p> <p>Parameters:</p> Name Type Description Default <code>max_deg</code> <code>int</code> <p>.</p> <code>0</code> <p>Returns:</p> Type Description <code>VectorInt</code> <p>Coefficients' array of length <code>max_deg</code> + 1 filled with zeros.</p> Source code in <code>src/lbpqc/primitives/polynomial/poly.py</code> <pre><code>@enforce_type_check\ndef zero_poly(max_deg: int = 0) -&gt; VectorInt:\n    r'''Explicitly constructs zero polynomial, i.e. a coefficient's array of length `max_deg` + 1 filled with zeros.\n\n    Args:\n        max_deg: .\n\n    Returns:\n        Coefficients' array of length `max_deg` + 1 filled with zeros.\n    '''\n\n    return np.zeros(max_deg + 1, dtype=int)\n</code></pre>"},{"location":"api/modules/polynomial/#src.lbpqc.primitives.polynomial.modpoly.ModIntPolyRing.__init__","title":"<code>__init__(modulus)</code>","text":"<p>Constructs the ring object for a given modulus.</p> <p>Parameters:</p> Name Type Description Default <code>modulus</code> <code>int</code> <p>Ring modulus.</p> required Source code in <code>src/lbpqc/primitives/polynomial/modpoly.py</code> <pre><code>@enforce_type_check\ndef __init__(self, modulus: int) -&gt; None:\n    r'''\n    Constructs the ring object for a given **modulus**.\n\n    Args:\n        modulus: Ring modulus.\n    '''\n    if modulus &lt;= 1: raise ValueError(\"Modulus has to be greater than 1\")\n    self.modulus = modulus\n</code></pre>"},{"location":"api/modules/polynomial/#src.lbpqc.primitives.polynomial.modpoly.ModIntPolyRing.add","title":"<code>add(polynomial_a, polynomial_b)</code>","text":"<p>Adds polynomial \\(a\\) to polynomial \\(b\\).</p> <p>Parameters:</p> Name Type Description Default <code>polynomial_a</code> <code>VectorInt</code> <p>polynomial's \\(a\\) coefficients.</p> required <code>polynomial_b</code> <code>VectorInt</code> <p>polynomial's \\(b\\) coefficients.</p> required <p>Returns:</p> Type Description <code>VectorModInt</code> <p>Coefficients array of polynomial \\(a + b\\).</p> Source code in <code>src/lbpqc/primitives/polynomial/modpoly.py</code> <pre><code>@enforce_type_check\ndef add(self, polynomial_a: VectorInt, polynomial_b: VectorInt) -&gt; VectorModInt:\n    r'''Adds polynomial $a$ to polynomial $b$.\n\n    Args:\n        polynomial_a: polynomial's $a$ coefficients.\n        polynomial_b: polynomial's $b$ coefficients.\n\n    Returns:\n        Coefficients array of polynomial $a + b$.\n    '''\n\n    return self.reduce(poly.add(polynomial_a, polynomial_b))\n</code></pre>"},{"location":"api/modules/polynomial/#src.lbpqc.primitives.polynomial.modpoly.ModIntPolyRing.coprime","title":"<code>coprime(polynomial_a, polynomial_b)</code>","text":"<p>checks whether two polynomials \\(a\\) and \\(b\\) are coprime in a ring. Checks whether \\(\\gcd(a,b)\\) reduced to monic polynomial is equal to constant polynomial \\(p \\equiv 1\\).</p> <p>Parameters:</p> Name Type Description Default <code>polynomial_a</code> <code>VectorInt</code> <p>Coefficients array of polynomial \\(a\\).</p> required <code>polynomial_b</code> <code>VectorInt</code> <p>Coefficients array of polynomial \\(b\\).</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if \\(a\\) and \\(b\\) are coprime in the ring, <code>False</code> otherwise.</p> Source code in <code>src/lbpqc/primitives/polynomial/modpoly.py</code> <pre><code>@enforce_type_check\ndef coprime(self, polynomial_a: VectorInt, polynomial_b: VectorInt) -&gt; bool:\n    r'''checks whether two polynomials $a$ and $b$ are coprime in a ring.  \n    Checks whether $\\gcd(a,b)$ reduced to monic polynomial is equal to constant polynomial $p \\equiv 1$.\n\n    Args:\n        polynomial_a: Coefficients array of polynomial $a$.\n        polynomial_b: Coefficients array of polynomial $b$.\n\n    Returns:\n        `True` if $a$ and $b$ are coprime in the ring, `False` otherwise.\n\n    '''\n    return np.all(self.to_monic(self.gcd(polynomial_a, polynomial_b)) == poly.monomial(1, 0))\n</code></pre>"},{"location":"api/modules/polynomial/#src.lbpqc.primitives.polynomial.modpoly.ModIntPolyRing.deg","title":"<code>deg(polynomial)</code>","text":"<p>Calculates degree of the given polynomial.</p> <p>Parameters:</p> Name Type Description Default <code>polynomial</code> <code>VectorInt</code> <p>polynomial's coefficients</p> required <p>Returns:</p> Type Description <code>int</code> <p>degree of the polynomial in the ring.</p> Source code in <code>src/lbpqc/primitives/polynomial/modpoly.py</code> <pre><code>@enforce_type_check\ndef deg(self, polynomial: VectorInt) -&gt; int:\n    r'''Calculates degree of the given polynomial.\n\n    Args:\n        polynomial: polynomial's coefficients\n\n    Returns:\n        degree of the polynomial in the ring.\n    '''\n\n    return poly.deg(self.reduce(polynomial))\n</code></pre>"},{"location":"api/modules/polynomial/#src.lbpqc.primitives.polynomial.modpoly.ModIntPolyRing.eea","title":"<code>eea(polynomial_a, polynomial_b)</code>","text":"<p>Extended Euclidean algorithm for polynomials, e.i algorithm that calculates coefficients for B\u00e9zout's identity.</p> <p>Parameters:</p> Name Type Description Default <code>polynomial_a</code> <code>VectorInt</code> <p>Coefficients array of polynomial \\(a\\).</p> required <code>polynomial_b</code> <code>VectorInt</code> <p>Coefficients array of polynomial \\(b\\).</p> required <p>Returns:</p> Type Description <code>Tuple[VectorModInt, VectorModInt, VectorModInt]</code> <p>Tuple of polynomials \\((d, s, t)\\) that satisfies \\(\\gcd(a,b) = d\\) and \\(s \\cdot a + t \\cdot b = d\\).</p> Source code in <code>src/lbpqc/primitives/polynomial/modpoly.py</code> <pre><code>@enforce_type_check\ndef eea(self, polynomial_a: VectorInt, polynomial_b: VectorInt) -&gt; Tuple[VectorModInt, VectorModInt, VectorModInt]:\n    r'''Extended Euclidean algorithm for polynomials, e.i algorithm that calculates coefficients for **B\u00e9zout's identity**.\n\n    Args:\n        polynomial_a: Coefficients array of polynomial $a$.\n        polynomial_b: Coefficients array of polynomial $b$.\n\n    Returns:\n        Tuple of polynomials $(d, s, t)$ that satisfies $\\gcd(a,b) = d$ and $s \\cdot a + t \\cdot b = d$.\n\n    '''\n\n    f0, f1 = self.reduce(polynomial_a), self.reduce(polynomial_b)\n    a0, a1 = poly.monomial(1, 0), poly.zero_poly()\n    b0, b1 = poly.zero_poly(), poly.monomial(1, 0)\n\n    while not self.is_zero(f1):\n        q, r = self.euclidean_div(f0, f1)\n\n        f0, f1 = f1, r\n\n        a0, a1 = a1, self.sub(a0, self.mul(q, a1))\n        b0, b1 = b1, self.sub(b0, self.mul(q, b1))\n\n    return f0, a0, b0\n</code></pre>"},{"location":"api/modules/polynomial/#src.lbpqc.primitives.polynomial.modpoly.ModIntPolyRing.euclidean_div","title":"<code>euclidean_div(polynomial_a, polynomial_b)</code>","text":"<p>Euclidean division (long division) for polynomials in the ring.</p> <p>Parameters:</p> Name Type Description Default <code>polynomial_a</code> <code>VectorInt</code> <p>.</p> required <code>polynomial_b</code> <code>VectorInt</code> <p>.</p> required <p>Returns:</p> Type Description <code>Tuple[VectorModInt, VectorModInt]</code> <p>Quotient and Remainder polynomials.</p> Source code in <code>src/lbpqc/primitives/polynomial/modpoly.py</code> <pre><code>@enforce_type_check\ndef euclidean_div(self,  polynomial_a: VectorInt, polynomial_b: VectorInt) -&gt; Tuple[VectorModInt, VectorModInt]:\n    r'''Euclidean division (long division) for polynomials in the ring.\n\n    Args:\n        polynomial_a: .\n        polynomial_b: .\n\n    Returns:\n        Quotient and Remainder polynomials.\n    '''\n\n    if self.is_zero(polynomial_b): raise ZeroDivisionError(\"Can't divide by zero polynomial\")\n\n    q = poly.zero_poly()\n    r = self.reduce(polynomial_a)\n\n    d = self.deg(polynomial_b)\n    c = polynomial_b[d]\n    while (dr := self.deg(r)) &gt;= d:\n        s = poly.monomial(r[dr] * modinv(c, self.modulus), dr - d)\n        q = self.add(q, s)\n        r = self.sub(r, self.mul(s, polynomial_b))\n\n    return q, r\n</code></pre>"},{"location":"api/modules/polynomial/#src.lbpqc.primitives.polynomial.modpoly.ModIntPolyRing.gcd","title":"<code>gcd(polynomial_a, polynomial_b)</code>","text":"<p>calculates \\(\\gcd\\) of polynomials \\(a\\) and \\(b\\) using euclidean algorithm. It's worth noting that int the polynomial ring, \\(\\gcd\\) is not unique.</p> <p>Parameters:</p> Name Type Description Default <code>polynomial_a</code> <code>VectorInt</code> <p>Coefficients array of polynomial \\(a\\).</p> required <code>polynomial_b</code> <code>VectorInt</code> <p>Coefficients array of polynomial \\(b\\).</p> required <p>Returns:</p> Type Description <code>VectorModInt</code> <p>Polynomial with maximal degree that divides both \\(a\\) and \\(b\\).</p> Source code in <code>src/lbpqc/primitives/polynomial/modpoly.py</code> <pre><code>@enforce_type_check\ndef gcd(self, polynomial_a: VectorInt, polynomial_b: VectorInt) -&gt; VectorModInt:\n    r'''calculates $\\gcd$ of polynomials $a$ and $b$ using euclidean algorithm.  \n    It's worth noting that int the polynomial ring, $\\gcd$ is not unique.\n\n    Args:\n        polynomial_a: Coefficients array of polynomial $a$.\n        polynomial_b: Coefficients array of polynomial $b$.\n\n    Returns:\n        Polynomial with maximal degree that divides both $a$ and $b$.\n\n    '''\n\n    r0 = self.reduce(polynomial_a)\n    r1 = self.reduce(polynomial_b)\n    if poly.deg(r1) &gt; poly.deg(r0):\n        r0, r1 = r1, r0\n\n    while not self.is_zero(r1):\n        r0, r1 = r1, self.rem(r0, r1)\n\n    return r0\n</code></pre>"},{"location":"api/modules/polynomial/#src.lbpqc.primitives.polynomial.modpoly.ModIntPolyRing.is_zero","title":"<code>is_zero(polynomial)</code>","text":"<p>Checks whether given polynomial is zero polynomial in the ring, so whether all it's coefficients are divisible by modulus.</p> <p>Parameters:</p> Name Type Description Default <code>polynomial</code> <code>VectorInt</code> <p>Coefficients array of polynomial to be checked.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if polynomial is zero polynomial in the ring else <code>False</code></p> Source code in <code>src/lbpqc/primitives/polynomial/modpoly.py</code> <pre><code>@enforce_type_check\ndef is_zero(self, polynomial: VectorInt) -&gt; bool:\n    r'''\n    Checks whether given polynomial is zero polynomial in the ring,\n    so whether all it's coefficients are divisible by **modulus**.\n\n    Args:\n        polynomial: Coefficients array of polynomial to be checked.\n\n    Returns:\n        `True` if polynomial is zero polynomial in the ring else `False`\n    '''\n    return poly.is_zero_poly(self.reduce(polynomial))\n</code></pre>"},{"location":"api/modules/polynomial/#src.lbpqc.primitives.polynomial.modpoly.ModIntPolyRing.mul","title":"<code>mul(polynomial_a, polynomial_b)</code>","text":"<p>Multiplies polynomial \\(a\\) and polynomial \\(b\\).</p> <p>Parameters:</p> Name Type Description Default <code>polynomial_a</code> <code>VectorInt</code> <p>polynomial's \\(a\\) coefficients.</p> required <code>polynomial_b</code> <code>VectorInt</code> <p>polynomial's \\(b\\) coefficients.</p> required <p>Returns:</p> Type Description <code>VectorModInt</code> <p>Coefficients array of polynomial \\(a \\cdot b\\).</p> Source code in <code>src/lbpqc/primitives/polynomial/modpoly.py</code> <pre><code>@enforce_type_check\ndef mul(self, polynomial_a: VectorInt, polynomial_b: VectorInt) -&gt; VectorModInt:\n    r'''Multiplies polynomial $a$ and polynomial $b$.\n\n    Args:\n        polynomial_a: polynomial's $a$ coefficients.\n        polynomial_b: polynomial's $b$ coefficients.\n\n    Returns:\n        Coefficients array of polynomial $a \\cdot b$.\n    '''\n\n    return self.reduce(poly.mul(polynomial_a, polynomial_b))\n</code></pre>"},{"location":"api/modules/polynomial/#src.lbpqc.primitives.polynomial.modpoly.ModIntPolyRing.reduce","title":"<code>reduce(polynomial)</code>","text":"<p>Reduces the given polynomial to it's cannonical equivalence class in the ring, i.e. reduces polynomials' coefficients modulo modulus.</p> <p>Parameters:</p> Name Type Description Default <code>polynomial</code> <code>VectorInt</code> <p>Polynomial's coefficients array.</p> required <p>Returns:</p> Type Description <code>VectorModInt</code> <p>Array of coefficients reduced modulo modulus.</p> Source code in <code>src/lbpqc/primitives/polynomial/modpoly.py</code> <pre><code>@enforce_type_check\ndef reduce(self, polynomial: VectorInt) -&gt; VectorModInt:\n    r'''\n    Reduces the given polynomial to it's cannonical equivalence class in the ring, i.e. reduces polynomials' coefficients modulo **modulus**.\n\n    Args:\n        polynomial: Polynomial's coefficients array.\n\n    Returns:\n        Array of coefficients reduced modulo **modulus**.\n    '''\n    return poly.trim(polynomial % self.modulus)\n</code></pre>"},{"location":"api/modules/polynomial/#src.lbpqc.primitives.polynomial.modpoly.ModIntPolyRing.rem","title":"<code>rem(polynomial_a, polynomial_b)</code>","text":"<p>Computes only remainder of the euclidean divions of two ring's polynomials.</p> <p>Parameters:</p> Name Type Description Default <code>polynomial_a</code> <code>VectorInt</code> <p>.</p> required <code>polynomial_b</code> <code>VectorInt</code> <p>.</p> required <p>Returns:</p> Type Description <code>VectorModInt</code> <p>Remainder of the euclidean division.</p> Source code in <code>src/lbpqc/primitives/polynomial/modpoly.py</code> <pre><code>@enforce_type_check\ndef rem(self, polynomial_a: VectorInt, polynomial_b: VectorInt) -&gt; VectorModInt:\n    r'''Computes only remainder of the euclidean divions of two ring's polynomials.\n\n    Args:\n        polynomial_a: .\n        polynomial_b: .\n\n    Returns:\n        Remainder of the euclidean division.\n    '''\n\n    if self.is_zero(polynomial_b): raise ZeroDivisionError(\"Can't divide by zero polynomial\")\n\n    _, r = self.euclidean_div(polynomial_a, polynomial_b)\n    return r\n</code></pre>"},{"location":"api/modules/polynomial/#src.lbpqc.primitives.polynomial.modpoly.ModIntPolyRing.sub","title":"<code>sub(polynomial_a, polynomial_b)</code>","text":"<p>Subtract polynomial \\(b\\) from polynomial \\(a\\).</p> <p>Parameters:</p> Name Type Description Default <code>polynomial_a</code> <code>VectorInt</code> <p>polynomial's \\(a\\) coefficients.</p> required <code>polynomial_b</code> <code>VectorInt</code> <p>polynomial's \\(b\\) coefficients.</p> required <p>Returns:</p> Type Description <code>VectorModInt</code> <p>Coefficients array of polynomial \\(a - b\\).</p> Source code in <code>src/lbpqc/primitives/polynomial/modpoly.py</code> <pre><code>@enforce_type_check\ndef sub(self, polynomial_a: VectorInt, polynomial_b: VectorInt) -&gt; VectorModInt:\n    r'''Subtract polynomial $b$ from polynomial $a$.\n\n    Args:\n        polynomial_a: polynomial's $a$ coefficients.\n        polynomial_b: polynomial's $b$ coefficients.\n\n    Returns:\n        Coefficients array of polynomial $a - b$.\n    '''\n\n\n    return self.reduce(poly.sub(polynomial_a, polynomial_b))\n</code></pre>"},{"location":"api/modules/polynomial/#src.lbpqc.primitives.polynomial.modpoly.ModIntPolyRing.to_monic","title":"<code>to_monic(polynomial)</code>","text":"<p>Reduces given polynomial to monic polynomial by multiplying it by scalar equal to modular multiplicative inverse of the highest power coefficient.</p> <p>Parameters:</p> Name Type Description Default <code>polynomial</code> <code>VectorInt</code> <p>.</p> required <p>Returns:</p> Type Description <code>VectorModInt</code> <p>Polynomial with leading coefficient equal to 1.</p> Source code in <code>src/lbpqc/primitives/polynomial/modpoly.py</code> <pre><code>@enforce_type_check\ndef to_monic(self, polynomial: VectorInt) -&gt; VectorModInt:\n    r'''Reduces given polynomial to monic polynomial by multiplying it by scalar equal to modular multiplicative inverse of the highest power coefficient.\n\n    Args:\n        polynomial: .\n\n    Returns:\n        Polynomial with leading coefficient equal to 1.\n    '''\n\n    leading_coeff = polynomial[self.deg(polynomial)]\n\n    return self.reduce(modinv(leading_coeff, self.modulus) * polynomial)\n</code></pre>"},{"location":"api/modules/polynomial/#src.lbpqc.primitives.polynomial.polyqring.PolyQuotientRing.__init__","title":"<code>__init__(poly_modulus, int_modulus)</code>","text":"<p>Constructs the ring object for a given polynomial modulus and integer modulus.</p> <p>Parameters:</p> Name Type Description Default <code>poly_modulus</code> <code>VectorInt</code> <p>Coefficients array of polynomial modulus fot the ring. The \\(q(X)\\) in \\(\\frac{\\mathbb{Z}_p[X]}{q(X)}\\).</p> required <code>int_modulus</code> <code>int</code> <p>Integer modulus for the ring. The \\(p\\) in \\(\\frac{\\mathbb{Z}_p[X]}{q(X)}\\).</p> required Source code in <code>src/lbpqc/primitives/polynomial/polyqring.py</code> <pre><code>@enforce_type_check\ndef __init__(self, poly_modulus: VectorInt, int_modulus: int) -&gt; None:\n    r'''Constructs the ring object for a given polynomial modulus and integer modulus.\n\n    Args:\n        poly_modulus: Coefficients array of polynomial modulus fot the ring. The $q(X)$ in $\\frac{\\mathbb{Z}_p[X]}{q(X)}$.\n        int_modulus: Integer modulus for the ring. The $p$ in $\\frac{\\mathbb{Z}_p[X]}{q(X)}$.\n    '''\n    self.poly_modulus = poly_modulus\n    self.int_modulus = int_modulus\n    self.Zm = modpoly.ModIntPolyRing(int_modulus)\n</code></pre>"},{"location":"api/modules/polynomial/#src.lbpqc.primitives.polynomial.polyqring.PolyQuotientRing.add","title":"<code>add(polynomial_a, polynomial_b)</code>","text":"<p>Adds polynomial \\(a\\) to polynomial \\(b\\).</p> <p>Parameters:</p> Name Type Description Default <code>polynomial_a</code> <code>VectorInt</code> <p>polynomial's \\(a\\) coefficients.</p> required <code>polynomial_b</code> <code>VectorInt</code> <p>polynomial's \\(b\\) coefficients.</p> required <p>Returns:</p> Type Description <code>VectorModInt</code> <p>Coefficients array of polynomial \\(a + b\\).</p> Source code in <code>src/lbpqc/primitives/polynomial/polyqring.py</code> <pre><code>@enforce_type_check\ndef add(self, polynomial_a: VectorInt, polynomial_b: VectorInt) -&gt; VectorModInt:\n    r'''Adds polynomial $a$ to polynomial $b$.\n\n    Args:\n        polynomial_a: polynomial's $a$ coefficients.\n        polynomial_b: polynomial's $b$ coefficients.\n\n    Returns:\n        Coefficients array of polynomial $a + b$.\n    '''\n\n    return self.reduce(self.Zm.add(polynomial_a, polynomial_b))\n</code></pre>"},{"location":"api/modules/polynomial/#src.lbpqc.primitives.polynomial.polyqring.PolyQuotientRing.inv","title":"<code>inv(polynomial)</code>","text":"<p>For a given polynomial \\(v\\), calculates it's multiplicative inverse in a ring.</p> <p>Parameters:</p> Name Type Description Default <code>polynomial</code> <code>VectorInt</code> <p>Polynomial's coefficients array.</p> required <p>Returns:</p> Type Description <code>VectorModInt</code> <p>Coefficients array of polynomial \\(u\\), such that \\(u \\cdot v \\equiv 1\\).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>When given polynomial is not an unit in the ring (it's not coprime with ring's polynomial modulus).</p> Source code in <code>src/lbpqc/primitives/polynomial/polyqring.py</code> <pre><code>@enforce_type_check\ndef inv(self, polynomial: VectorInt) -&gt; VectorModInt:\n    r'''For a given polynomial $v$, calculates it's multiplicative inverse in a ring.\n\n    Args:\n        polynomial: Polynomial's coefficients array.\n\n    Returns:\n        Coefficients array of polynomial $u$, such that $u \\cdot v \\equiv 1$.\n\n    Raises:\n        ValueError: When given polynomial is not an unit in the ring (it's not coprime with ring's polynomial modulus).\n\n    '''\n\n    if not self.Zm.coprime(polynomial, self.poly_modulus): raise ValueError(\"Inverse does not exists\")\n\n    gcd, u, _ = self.Zm.eea(polynomial, self.poly_modulus)\n\n    c = integer_ring.modinv(gcd, self.int_modulus)\n\n    return self.reduce(u * c)\n</code></pre>"},{"location":"api/modules/polynomial/#src.lbpqc.primitives.polynomial.polyqring.PolyQuotientRing.mul","title":"<code>mul(polynomial_a, polynomial_b)</code>","text":"<p>Multiplies polynomial \\(a\\) and polynomial \\(b\\).</p> <p>Parameters:</p> Name Type Description Default <code>polynomial_a</code> <code>VectorInt</code> <p>polynomial's \\(a\\) coefficients.</p> required <code>polynomial_b</code> <code>VectorInt</code> <p>polynomial's \\(b\\) coefficients.</p> required <p>Returns:</p> Type Description <code>VectorModInt</code> <p>Coefficients array of polynomial \\(a \\cdot b\\).</p> Source code in <code>src/lbpqc/primitives/polynomial/polyqring.py</code> <pre><code>@enforce_type_check\ndef mul(self, polynomial_a: VectorInt, polynomial_b: VectorInt) -&gt; VectorModInt:\n    r'''Multiplies polynomial $a$ and polynomial $b$.\n\n    Args:\n        polynomial_a: polynomial's $a$ coefficients.\n        polynomial_b: polynomial's $b$ coefficients.\n\n    Returns:\n        Coefficients array of polynomial $a \\cdot b$.\n    '''\n\n    return self.reduce(self.Zm.mul(polynomial_a, polynomial_b))\n</code></pre>"},{"location":"api/modules/polynomial/#src.lbpqc.primitives.polynomial.polyqring.PolyQuotientRing.reduce","title":"<code>reduce(polynomial)</code>","text":"<p>Reduces the given polynomial \\(u\\) to it's cannonical equivalence class in the ring, i.e. takes, the remainder of division \\(\\frac{u}{q}\\), where \\(q\\) is polynomial modulus for the ring. The division is performed in \\(\\mathbb{Z}_p[X]\\) ring.</p> <p>Parameters:</p> Name Type Description Default <code>polynomial</code> <code>VectorInt</code> <p>Polynomial's coefficients array.</p> required <p>Returns:</p> Type Description <code>VectorModInt</code> <p>Coefficients array of polynomial that is the remainder of the Euclidean division.</p> Source code in <code>src/lbpqc/primitives/polynomial/polyqring.py</code> <pre><code>@enforce_type_check\ndef reduce(self, polynomial: VectorInt) -&gt; VectorModInt:\n    r'''Reduces the given polynomial $u$ to it's cannonical equivalence class in the ring,\n    i.e. takes, the remainder of division $\\frac{u}{q}$, where $q$ is polynomial modulus for the ring.  \n    The division is performed in $\\mathbb{Z}_p[X]$ ring.\n\n    Args:\n        polynomial: Polynomial's coefficients array.\n\n    Returns:\n        Coefficients array of polynomial that is the remainder of the Euclidean division.\n    '''\n    return self.Zm.rem(polynomial, self.poly_modulus)\n</code></pre>"},{"location":"api/modules/polynomial/#src.lbpqc.primitives.polynomial.polyqring.PolyQuotientRing.sub","title":"<code>sub(polynomial_a, polynomial_b)</code>","text":"<p>Subtract polynomial \\(b\\) from polynomial \\(a\\).</p> <p>Parameters:</p> Name Type Description Default <code>polynomial_a</code> <code>VectorInt</code> <p>polynomial's \\(a\\) coefficients.</p> required <code>polynomial_b</code> <code>VectorInt</code> <p>polynomial's \\(b\\) coefficients.</p> required <p>Returns:</p> Type Description <code>VectorModInt</code> <p>Coefficients array of polynomial \\(a - b\\).</p> Source code in <code>src/lbpqc/primitives/polynomial/polyqring.py</code> <pre><code>@enforce_type_check\ndef sub(self, polynomial_a: VectorInt, polynomial_b: VectorInt) -&gt; VectorModInt:\n    r'''Subtract polynomial $b$ from polynomial $a$.\n\n    Args:\n        polynomial_a: polynomial's $a$ coefficients.\n        polynomial_b: polynomial's $b$ coefficients.\n\n    Returns:\n        Coefficients array of polynomial $a - b$.\n    '''\n\n    return self.reduce(self.Zm.sub(polynomial_a, polynomial_b))\n</code></pre>"},{"location":"api/modules/rng/","title":"Rng","text":"Source code in <code>src/lbpqc/primitives/rng.py</code> <pre><code>class RNG:\n    def __init__(self, seed) -&gt; None:\n        r'''\n        Initialize numpy rng with seed value.  \n        Use `secrets.randbits(128)` for more cryptographicly secure rng.\n        '''\n        self._nprng = np.random.default_rng(seed)\n        self._pyrng = random.Random(seed)\n\n\n\n    @property\n    def rng(self):\n        r'''\n        Access the underlying `numpy` rng object.\n\n        Args:\n\n        Returns:\n\n        '''\n        return self._nprng\n\n\n    def sample_rounded_gaussian(self, q, alpha, size = None) -&gt; int | VectorInt | MatrixInt:\n        return np.rint(self.rng.normal(0, (q * alpha) / (2 * np.pi), size)).astype(int)\n\n\n    def sample_discrete_gaussian(self, s: float, c: float, n: int, k: int = 100) -&gt; int:\n        r'''\n        *How to Use a Short Basis: Trapdoors for Hard Lattices and New Cryptographic Constructions; page 14; 4.1 Sampling Integers;*\n\n        Args:\n\n        Returns:\n\n        '''\n        gaussian = lambda x, s, c: np.exp((-np.pi * np.dot(x - c, x - c)) / (s * s))\n        t = np.log(n)\n        a = int(np.ceil(c - s * t))\n        b = int(np.floor(c + s * t))\n        for _ in range(k * int(np.ceil(t))):\n            x = self.rng.integers(a, b, endpoint=True)\n            if self.rng.random() &lt; gaussian(x, s, c):\n                return x\n\n        raise RuntimeError(\"This shouldn't happen\")\n\n\n    def sample_uniform_Zq(self, q: int, size : None | int | Tuple[int,int] = None) -&gt; ModInt | VectorModInt | MatrixModInt:\n        r'''\n        Sample uniformly from $\\mathbb{Z}_{q}$ ring.  \n        If size is None, returns single element.  \n        If size is an int, returns vector (1 dim np.ndarray) with given size.  \n        If size is a tuple, returns matrix (2 dim np.ndarray) with given shape.\n\n        Args:\n\n        Returns:\n\n        '''\n        return self.rng.integers(0, q, size)\n\n\n    def _get_dist(self, name: str, *args):\n        match name:\n            case 'rounded':\n                return self.sample_rounded_gaussian(*args)\n            case 'discrete':\n                return self.sample_discrete_gaussian(*args)\n\n        raise ValueError(f\"Unknown distribution {name}\")\n\n\n    def LWE_dist(self, q: int, s: VectorInt, m: int, err_dist: str, *args) -&gt; Tuple[MatrixModInt, VectorInt]:\n        r'''\n\n        Args:\n\n        Returns:\n\n        '''\n        n = s.shape[0]\n\n        e = np.array([self._get_dist(err_dist, *args) for _ in range(m)])\n        A = self.sample_uniform_Zq(q, (m, n))\n        b = A @ s + e\n        return A, b\n\n\n    def row_LWE_dist(self, q: int, s: VectorInt, err_dist: str, *args) -&gt; Tuple[VectorInt, int]:\n        r'''\n\n        Args:\n\n        Returns:\n\n        '''\n        n = s.shape[0]\n        e = self._get_dist(err_dist, *args)\n        a = self.sample_uniform_Zq(q, n)\n        b = np.dot(a, s)\n        return a, b\n\n\n    def LWR_dist(self, q: int, p: int, s: VectorInt, m :int) -&gt; Tuple[MatrixModInt, VectorModInt]:\n        r'''\n\n        Args:\n\n        Returns:\n\n        '''\n        n = s.shape[0]\n        A = self.sample_uniform_Zq(q, (m, n))\n        b = integer_ring.LWR_rounding(A @ s, q, p)\n        return A, b\n\n\n    def row_LWR_dist(self, q: int, p: int, s: VectorInt) -&gt; Tuple[VectorInt, ModInt]:\n        r'''\n\n        Args:\n\n        Returns:\n\n        '''\n        n = s.shape[0]\n        a = self.sample_uniform_Zq(q, n)\n        b = integer_ring.LWR_rounding(np.dot(a, s), q, p)\n        return a, b\n\n\n    def sample_Zq_subset(self, q: int) -&gt; VectorModInt:\n        r'''\n\n        Args:\n\n        Returns:\n\n        '''\n        subset_size = self.rng.integers(0, q)\n        return self.rng.choice(q, subset_size, replace=False)\n\n\n    def sample_prime(self, a: int, b: int = None):\n        r'''\n        samples a random prime from interval [a, b)\n        number of primes in interval $(0, x]$ - $\\pi(x) \\approx \\frac{x}{\\log{x}}$\n        so number of primes in [a, b) is approximetly equal to $P = \\frac{b}{\\log{b}} - \\frac{a}{\\log{a}}$.\n        probabiliy of uniformly chosen integer from (a,b] being a prime - $p = \\frac{P}{b - a}$\n\n        P(not getting prime) = 1 - p\n        P(not getting any prime in n trials) = (1 - p)^n\n        P(getting at least one prime in n trials) = 1 - (1 - p)^n\n        0.99 = 1 - (1 - p)^n\n        (1 - p)^n = 0.01\n        n = log(0.01, 1 - p)\n        n = ln(0.01)/ln(1 - p)\n\n        So in order to be 99% sure that some prime number was sampled, we need to perform n trials\n        where n = ln(0.01)/ln(1 - p)\n\n        Args:\n\n        Returns:\n\n        '''\n        if b is None:\n            b = a\n            a = 0\n\n        if b &lt;= a:\n            raise ValueError(f\"[{a}, {b}) is not a proper interval\")\n\n        if b &lt;= 0:\n            raise ValueError(f\"there are no prime numbers in interval [{a}, {b})\")\n\n        if a &lt; 0:\n            a = 0\n\n        bigint_log = lambda n, b: int((n.bit_length() - 1) // math.log2(b))\n\n\n\n        approx_number_of_primes = b // (math.log(b) if b.bit_length() &lt; 512 else bigint_log(b, math.e))\n        if a != 0:\n            approx_number_of_primes -= a // (math.log(a) if a.bit_length() &lt; 512 else bigint_log(a, math.e))\n        is_prime_probability = approx_number_of_primes / (b - a)\n\n        number_of_samples = int(math.log(0.01) / math.log(1 - is_prime_probability)) + 1\n\n        int_gen = (lambda a,b: self.rng.integers(a,b)) if b &lt; 2 ** 63 - 1 else (lambda a,b: self._pyrng.randint(a, b - 1))\n\n        for _ in range(number_of_samples):\n            prime_candidate = int_gen(a,b)\n            if miller_rabin_primality_test(prime_candidate, 15, int_gen):\n                return prime_candidate\n\n        raise ValueError(\"exceeded maximum number of trials for sampling a prime from [a, b)\")\n\n\n    def sample_kbits_prime(self, kbits: int):\n        r'''\n\n        Args:\n\n        Returns:\n\n        '''\n        a = 2**(kbits - 1)\n        b = 2**kbits\n        return self.sample_prime(a, b)\n</code></pre>"},{"location":"api/modules/rng/#src.lbpqc.primitives.rng.RNG.rng","title":"<code>rng</code>  <code>property</code>","text":"<p>Access the underlying <code>numpy</code> rng object.</p> <p>Args:</p> <p>Returns:</p>"},{"location":"api/modules/rng/#src.lbpqc.primitives.rng.RNG.LWE_dist","title":"<code>LWE_dist(q, s, m, err_dist, *args)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/rng.py</code> <pre><code>def LWE_dist(self, q: int, s: VectorInt, m: int, err_dist: str, *args) -&gt; Tuple[MatrixModInt, VectorInt]:\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    n = s.shape[0]\n\n    e = np.array([self._get_dist(err_dist, *args) for _ in range(m)])\n    A = self.sample_uniform_Zq(q, (m, n))\n    b = A @ s + e\n    return A, b\n</code></pre>"},{"location":"api/modules/rng/#src.lbpqc.primitives.rng.RNG.LWR_dist","title":"<code>LWR_dist(q, p, s, m)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/rng.py</code> <pre><code>def LWR_dist(self, q: int, p: int, s: VectorInt, m :int) -&gt; Tuple[MatrixModInt, VectorModInt]:\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    n = s.shape[0]\n    A = self.sample_uniform_Zq(q, (m, n))\n    b = integer_ring.LWR_rounding(A @ s, q, p)\n    return A, b\n</code></pre>"},{"location":"api/modules/rng/#src.lbpqc.primitives.rng.RNG.__init__","title":"<code>__init__(seed)</code>","text":"<p>Initialize numpy rng with seed value. Use <code>secrets.randbits(128)</code> for more cryptographicly secure rng.</p> Source code in <code>src/lbpqc/primitives/rng.py</code> <pre><code>def __init__(self, seed) -&gt; None:\n    r'''\n    Initialize numpy rng with seed value.  \n    Use `secrets.randbits(128)` for more cryptographicly secure rng.\n    '''\n    self._nprng = np.random.default_rng(seed)\n    self._pyrng = random.Random(seed)\n</code></pre>"},{"location":"api/modules/rng/#src.lbpqc.primitives.rng.RNG.row_LWE_dist","title":"<code>row_LWE_dist(q, s, err_dist, *args)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/rng.py</code> <pre><code>def row_LWE_dist(self, q: int, s: VectorInt, err_dist: str, *args) -&gt; Tuple[VectorInt, int]:\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    n = s.shape[0]\n    e = self._get_dist(err_dist, *args)\n    a = self.sample_uniform_Zq(q, n)\n    b = np.dot(a, s)\n    return a, b\n</code></pre>"},{"location":"api/modules/rng/#src.lbpqc.primitives.rng.RNG.row_LWR_dist","title":"<code>row_LWR_dist(q, p, s)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/rng.py</code> <pre><code>def row_LWR_dist(self, q: int, p: int, s: VectorInt) -&gt; Tuple[VectorInt, ModInt]:\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    n = s.shape[0]\n    a = self.sample_uniform_Zq(q, n)\n    b = integer_ring.LWR_rounding(np.dot(a, s), q, p)\n    return a, b\n</code></pre>"},{"location":"api/modules/rng/#src.lbpqc.primitives.rng.RNG.sample_Zq_subset","title":"<code>sample_Zq_subset(q)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/rng.py</code> <pre><code>def sample_Zq_subset(self, q: int) -&gt; VectorModInt:\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    subset_size = self.rng.integers(0, q)\n    return self.rng.choice(q, subset_size, replace=False)\n</code></pre>"},{"location":"api/modules/rng/#src.lbpqc.primitives.rng.RNG.sample_discrete_gaussian","title":"<code>sample_discrete_gaussian(s, c, n, k=100)</code>","text":"<p>How to Use a Short Basis: Trapdoors for Hard Lattices and New Cryptographic Constructions; page 14; 4.1 Sampling Integers;</p> <p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/rng.py</code> <pre><code>def sample_discrete_gaussian(self, s: float, c: float, n: int, k: int = 100) -&gt; int:\n    r'''\n    *How to Use a Short Basis: Trapdoors for Hard Lattices and New Cryptographic Constructions; page 14; 4.1 Sampling Integers;*\n\n    Args:\n\n    Returns:\n\n    '''\n    gaussian = lambda x, s, c: np.exp((-np.pi * np.dot(x - c, x - c)) / (s * s))\n    t = np.log(n)\n    a = int(np.ceil(c - s * t))\n    b = int(np.floor(c + s * t))\n    for _ in range(k * int(np.ceil(t))):\n        x = self.rng.integers(a, b, endpoint=True)\n        if self.rng.random() &lt; gaussian(x, s, c):\n            return x\n\n    raise RuntimeError(\"This shouldn't happen\")\n</code></pre>"},{"location":"api/modules/rng/#src.lbpqc.primitives.rng.RNG.sample_kbits_prime","title":"<code>sample_kbits_prime(kbits)</code>","text":"<p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/rng.py</code> <pre><code>def sample_kbits_prime(self, kbits: int):\n    r'''\n\n    Args:\n\n    Returns:\n\n    '''\n    a = 2**(kbits - 1)\n    b = 2**kbits\n    return self.sample_prime(a, b)\n</code></pre>"},{"location":"api/modules/rng/#src.lbpqc.primitives.rng.RNG.sample_prime","title":"<code>sample_prime(a, b=None)</code>","text":"<p>samples a random prime from interval [a, b) number of primes in interval \\((0, x]\\) - \\(\\pi(x) \\approx \\frac{x}{\\log{x}}\\) so number of primes in [a, b) is approximetly equal to \\(P = \\frac{b}{\\log{b}} - \\frac{a}{\\log{a}}\\). probabiliy of uniformly chosen integer from (a,b] being a prime - \\(p = \\frac{P}{b - a}\\)</p> <p>P(not getting prime) = 1 - p P(not getting any prime in n trials) = (1 - p)^n P(getting at least one prime in n trials) = 1 - (1 - p)^n 0.99 = 1 - (1 - p)^n (1 - p)^n = 0.01 n = log(0.01, 1 - p) n = ln(0.01)/ln(1 - p)</p> <p>So in order to be 99% sure that some prime number was sampled, we need to perform n trials where n = ln(0.01)/ln(1 - p)</p> <p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/rng.py</code> <pre><code>def sample_prime(self, a: int, b: int = None):\n    r'''\n    samples a random prime from interval [a, b)\n    number of primes in interval $(0, x]$ - $\\pi(x) \\approx \\frac{x}{\\log{x}}$\n    so number of primes in [a, b) is approximetly equal to $P = \\frac{b}{\\log{b}} - \\frac{a}{\\log{a}}$.\n    probabiliy of uniformly chosen integer from (a,b] being a prime - $p = \\frac{P}{b - a}$\n\n    P(not getting prime) = 1 - p\n    P(not getting any prime in n trials) = (1 - p)^n\n    P(getting at least one prime in n trials) = 1 - (1 - p)^n\n    0.99 = 1 - (1 - p)^n\n    (1 - p)^n = 0.01\n    n = log(0.01, 1 - p)\n    n = ln(0.01)/ln(1 - p)\n\n    So in order to be 99% sure that some prime number was sampled, we need to perform n trials\n    where n = ln(0.01)/ln(1 - p)\n\n    Args:\n\n    Returns:\n\n    '''\n    if b is None:\n        b = a\n        a = 0\n\n    if b &lt;= a:\n        raise ValueError(f\"[{a}, {b}) is not a proper interval\")\n\n    if b &lt;= 0:\n        raise ValueError(f\"there are no prime numbers in interval [{a}, {b})\")\n\n    if a &lt; 0:\n        a = 0\n\n    bigint_log = lambda n, b: int((n.bit_length() - 1) // math.log2(b))\n\n\n\n    approx_number_of_primes = b // (math.log(b) if b.bit_length() &lt; 512 else bigint_log(b, math.e))\n    if a != 0:\n        approx_number_of_primes -= a // (math.log(a) if a.bit_length() &lt; 512 else bigint_log(a, math.e))\n    is_prime_probability = approx_number_of_primes / (b - a)\n\n    number_of_samples = int(math.log(0.01) / math.log(1 - is_prime_probability)) + 1\n\n    int_gen = (lambda a,b: self.rng.integers(a,b)) if b &lt; 2 ** 63 - 1 else (lambda a,b: self._pyrng.randint(a, b - 1))\n\n    for _ in range(number_of_samples):\n        prime_candidate = int_gen(a,b)\n        if miller_rabin_primality_test(prime_candidate, 15, int_gen):\n            return prime_candidate\n\n    raise ValueError(\"exceeded maximum number of trials for sampling a prime from [a, b)\")\n</code></pre>"},{"location":"api/modules/rng/#src.lbpqc.primitives.rng.RNG.sample_uniform_Zq","title":"<code>sample_uniform_Zq(q, size=None)</code>","text":"<p>Sample uniformly from \\(\\mathbb{Z}_{q}\\) ring. If size is None, returns single element. If size is an int, returns vector (1 dim np.ndarray) with given size. If size is a tuple, returns matrix (2 dim np.ndarray) with given shape.</p> <p>Args:</p> <p>Returns:</p> Source code in <code>src/lbpqc/primitives/rng.py</code> <pre><code>def sample_uniform_Zq(self, q: int, size : None | int | Tuple[int,int] = None) -&gt; ModInt | VectorModInt | MatrixModInt:\n    r'''\n    Sample uniformly from $\\mathbb{Z}_{q}$ ring.  \n    If size is None, returns single element.  \n    If size is an int, returns vector (1 dim np.ndarray) with given size.  \n    If size is a tuple, returns matrix (2 dim np.ndarray) with given shape.\n\n    Args:\n\n    Returns:\n\n    '''\n    return self.rng.integers(0, q, size)\n</code></pre>"},{"location":"examples/LWE_primary_attack/","title":"LWE primary attack","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nfrom lbpqc.primitives.rng import RNG\nfrom lbpqc.primitives import matrix\nfrom lbpqc.primitives.lattice import embeddings, reductions, fullrank\n</pre> import numpy as np from lbpqc.primitives.rng import RNG from lbpqc.primitives import matrix from lbpqc.primitives.lattice import embeddings, reductions, fullrank In\u00a0[2]: Copied! <pre>rng = RNG(0)\n</pre> rng = RNG(0) In\u00a0[3]: Copied! <pre>m, n, q = 10, 5, 17 # These are parameters for LWE distribution\ns = np.array([2,2,1,4,5]) # Here we chose a secret vector\n\n# We sample from LWE distribution, for error distribution we use rounded gaussian with mean = 0 and stddev = q * (1/n) / 2pi\nA, b = rng.LWE_dist(q, s, m, \"rounded\", q, 1 / n)\nprint(\"LWE distribution:\")\nprint(\"A:\")\nprint(A)\nprint()\nprint(\"b:\")\nprint(b)\n\nprint(\"s:\")\nprint(s)\ne = b - A@s\nprint(\"e = b - As\")\nprint(\"e:\")\nprint(e)\n</pre> m, n, q = 10, 5, 17 # These are parameters for LWE distribution s = np.array([2,2,1,4,5]) # Here we chose a secret vector  # We sample from LWE distribution, for error distribution we use rounded gaussian with mean = 0 and stddev = q * (1/n) / 2pi A, b = rng.LWE_dist(q, s, m, \"rounded\", q, 1 / n) print(\"LWE distribution:\") print(\"A:\") print(A) print() print(\"b:\") print(b)  print(\"s:\") print(s) e = b - A@s print(\"e = b - As\") print(\"e:\") print(e) <pre>LWE distribution:\nA:\n[[ 4 13 11  0  6]\n [14  9  0 13 12]\n [14  2  1 14  0]\n [ 9  1  5  8  7]\n [ 6  0  0  2  0]\n [11  8 11  4 10]\n [12  6  7 16 13]\n [16  6 11 16 11]\n [14 11 11  6 14]\n [ 2  9 12 14  8]]\n\nb:\n[ 75 158  89  92  20 115 173 175 155 129]\ns:\n[2 2 1 4 5]\ne = b - As\ne:\n[ 0  0  0  0  0  0  1  1  0 -1]\n</pre> <p>Primary attack is achieved by constructing a lattice from our LWE pair $(A, \\mathbf{b})$ thru some embedding method and then by using lattice reduction algorithm we can obtain a short vector that should allow us to reconstruct the secret vector $\\mathbf{s}$.</p> <p>First we will reduce the LWE problem to BDD by constructing the associated q-ary lattice $$     \\mathcal{L'} = \\left\\{ \\mathbf{y'} \\in \\mathbb{Z}^m : \\mathbf{y'} = A\\mathbf{x'}\\mod q, \\quad \\forall \\mathbf{x'} \\in \\mathbb{Z}^n \\right \\} $$ We can try to solve the BDD directly by using babai's nearest plane algorithm, or furthemore reduce the BDD to SVP with Kannan's embedding. Let's first try solving BDD.</p> In\u00a0[4]: Copied! <pre>print(\"LWE as BDD problem:\")\nBDD_Basis =  embeddings.q_ary_basis(A, q)\nprint(BDD_Basis)\n</pre> print(\"LWE as BDD problem:\") BDD_Basis =  embeddings.q_ary_basis(A, q) print(BDD_Basis) <pre>LWE as BDD problem:\n[[ 1  0  0  0  0 13  1 10  2  1]\n [ 0  1  0  0  0  7  2  9 16 10]\n [ 0  0  1  0  0 13 13  1 13 10]\n [ 0  0  0  1  0  5  0 14  2  5]\n [ 0  0  0  0  1  7  6 14  4  5]\n [ 0  0  0  0  0 17  0  0  0  0]\n [ 0  0  0  0  0  0 17  0  0  0]\n [ 0  0  0  0  0  0  0 17  0  0]\n [ 0  0  0  0  0  0  0  0 17  0]\n [ 0  0  0  0  0  0  0  0  0 17]]\n</pre> <p>When solving BDD with babai's nearest plane algorithm we use vector $\\mathbf{b}$ as our target vector. The nearest plane algorithm will give us some close lattice vector $\\mathbf{w}$ that satisfies $\\mathbf{w} = A\\mathbf{x'} \\mod q$ for all $x \\in \\mathbb{Z}^n$ and since the error vector $\\mathbf{e}$ is relatively short, we can expect that $\\mathbf{w} = A\\mathbf{s} \\mod q$ where $\\mathbf{s}$ is a secret we are looking for. In order to obtain the secret vector we need to solve linear system of equations, we can use Gaussian-Jordan elimination for that. One caveat is that we are solving the system in $\\mathbb{Z}_q$.</p> In\u00a0[5]: Copied! <pre>w = reductions.babai_nearest_plane(BDD_Basis, b).astype(int)\nAw = np.block([A, w.reshape(-1,1)])\nR, _ = matrix.mod_RREF(Aw, q)\n# since we have more equations than variables, after first elimination we fill with zeros the redundant rows\n# after that, in order to solve the system we perfom second elimination only on the first n rows\nsw = matrix.mod_RREF(R[:len(s)], q)[0][:, -1]\nprint(\"recovered secret:\")\nprint(sw)\nprint(\"true secret:\")\nprint(s)\n</pre> w = reductions.babai_nearest_plane(BDD_Basis, b).astype(int) Aw = np.block([A, w.reshape(-1,1)]) R, _ = matrix.mod_RREF(Aw, q) # since we have more equations than variables, after first elimination we fill with zeros the redundant rows # after that, in order to solve the system we perfom second elimination only on the first n rows sw = matrix.mod_RREF(R[:len(s)], q)[0][:, -1] print(\"recovered secret:\") print(sw) print(\"true secret:\") print(s) <pre>recovered secret:\n[2 2 1 4 5]\ntrue secret:\n[2 2 1 4 5]\n</pre> <p>Now we can use Kannan's embedding. For Kannan's embedding we define the embedding lattice $\\mathcal{L_K}$ as follows $$ \\mathcal{L_K} := \\left\\{ \\mathbf{y} \\in \\mathbb{Z}^{m + 1} : \\mathbf{y} = \\bar{A}x \\mod q, \\quad \\forall \\mathbf{x} \\in \\mathbb{Z}^{n+1}, \\bar{A} =  \\begin{pmatrix} A &amp; \\mathbf{b} \\newline \\mathbf{0} &amp; 1 \\end{pmatrix} \\right \\} $$ If the columns of the matrix $\\bar{a}$ are linearly independed (given the nature of LWE there is a very high chance they are), then $\\mathbf{v}^T = (\\mathbf{e}^T| 1)$ is a short vector in the lattice. We can find it by using some lattice reduction algorithm e.g. LLL. Recall that $A\\mathbf{s} = \\mathbf{b} - \\mathbf{e}$, so we can solve for $\\mathbf{s}$ using the same technis as for BDD.</p> In\u00a0[6]: Copied! <pre>Id = lambda n: np.identity(n, int)\nZn = lambda m, n: np.zeros((m,n), int)\n\nAd = np.block([[A, b.reshape(-1, 1)], [Zn(1, n), np.array([1])]])\nKannans_Basis = embeddings.q_ary_basis(Ad, q)\n\nprint(\"Kannan's embedding\")\nprint(Kannans_Basis)\n</pre> Id = lambda n: np.identity(n, int) Zn = lambda m, n: np.zeros((m,n), int)  Ad = np.block([[A, b.reshape(-1, 1)], [Zn(1, n), np.array([1])]]) Kannans_Basis = embeddings.q_ary_basis(Ad, q)  print(\"Kannan's embedding\") print(Kannans_Basis) <pre>Kannan's embedding\n[[ 1  0  0  0  0 13  0  9  2  2 16]\n [ 0  1  0  0  0  7  0  7 16 12 15]\n [ 0  0  1  0  0 13  0  5 13  6  4]\n [ 0  0  0  1  0  5  0 14  2  5  0]\n [ 0  0  0  0  1  7  0  8  4 11 11]\n [ 0  0  0  0  0 17  0  0  0  0  0]\n [ 0  0  0  0  0  0  1  1  0 16  1]\n [ 0  0  0  0  0  0  0 17  0  0  0]\n [ 0  0  0  0  0  0  0  0 17  0  0]\n [ 0  0  0  0  0  0  0  0  0 17  0]\n [ 0  0  0  0  0  0  0  0  0  0 17]]\n</pre> In\u00a0[7]: Copied! <pre>v = reductions.LLL(Kannans_Basis).astype(int)[0]\nprint(\"v should have a form of (e | 1) where e is LWE noise vector so A * s = b - v\")\nprint(\"v:\")\nprint(v)\nprint(\"e:\")\nprint(e)\nprint()\nAs = b - v[:m] if v[-1] == 1 else b + v[:m]\nAw = np.block([A, As.reshape(-1,1)])\nR, _ = matrix.mod_RREF(Aw, q)\nss = matrix.mod_RREF(R[:len(s)], q)[0][:, -1]\nprint(\"recovered secret:\")\nprint(ss)\nprint(\"true secret:\")\nprint(s)\n</pre> v = reductions.LLL(Kannans_Basis).astype(int)[0] print(\"v should have a form of (e | 1) where e is LWE noise vector so A * s = b - v\") print(\"v:\") print(v) print(\"e:\") print(e) print() As = b - v[:m] if v[-1] == 1 else b + v[:m] Aw = np.block([A, As.reshape(-1,1)]) R, _ = matrix.mod_RREF(Aw, q) ss = matrix.mod_RREF(R[:len(s)], q)[0][:, -1] print(\"recovered secret:\") print(ss) print(\"true secret:\") print(s) <pre>v should have a form of (e | 1) where e is LWE noise vector so A * s = b - v\nv:\n[ 0  0  0  0  0  0 -1 -1  0  1 -1]\ne:\n[ 0  0  0  0  0  0  1  1  0 -1]\n\nrecovered secret:\n[2 2 1 4 5]\ntrue secret:\n[2 2 1 4 5]\n</pre>"},{"location":"examples/LWE_primary_attack/#primary-attack-on-search-lwe-problem","title":"Primary attack on search-LWE problem\u00b6","text":"<p>In this notebook we are going to solve search-LWE by using primary attack. First let's define the LWE. Given parameters $n, q \\in \\mathbb{Z} $ and some non-uniform probability distribution $\\chi$ on $\\mathbb{Z}_q$ we define an LWE sample $(\\mathbf{a},b)$ for a secret vector $\\mathbf{s} \\in {\\mathbb{Z}^n_q}$ as follows $$ \\begin{align*} \\mathbf{a} &amp;\\leftarrow \\operatorname{Uniform}(\\mathbb{Z}^n_q) \\newline b &amp;:= \\langle \\mathbf{a}, \\mathbf{s}\\rangle + e \\end{align*} $$ where error $e$ is sampled from $\\chi$ distribution. $$ \\mathbf{e} \\leftarrow \\chi $$ As we take more samples, we can arrange them into a matrix/vector form. So for $m$ samples we define matrix $A \\in \\mathbb{Z}^{m\\times n}_q$ to be obtained from uniform distribution and use vector $\\mathbf{e} \\in \\mathbb{Z}^m$ for error $$ \\begin{align*} A &amp;\\leftarrow \\operatorname{Uniform}(\\mathbb{Z}^{m\\times n}_q) \\newline \\mathbf{e} &amp;\\leftarrow \\chi^{m} \\newline \\mathbf{b} &amp;:= A\\mathbf{s} + \\mathbf{e} \\end{align*} $$ For search-LWE problem, given only pair $(A, \\mathbf{b})$ we need to obtain secret vector $\\mathbf{s}$.</p>"},{"location":"examples/attacking_congruential_pkc/","title":"Congruential PKC","text":"In\u00a0[1]: Copied! <pre>from lbpqc.primitives.integer import integer_ring\nimport math\n\nq = 122430513841\nf = 231241\ng = 195698\n\nassert 0 &lt; f &lt; (q/2) ** 0.5\nassert (q/4) ** 0.5 &lt; g &lt; (q/2) ** 0.5\nassert math.gcd(f, q * g) == 1\n\nh = (integer_ring.modinv(f,q) * g) % q\n\npublic_key = h\nprivate_key = (f,g)\n\nprint(\"private key:\", private_key)\nprint(\"public key:\", public_key)\n</pre> from lbpqc.primitives.integer import integer_ring import math  q = 122430513841 f = 231241 g = 195698  assert 0 &lt; f &lt; (q/2) ** 0.5 assert (q/4) ** 0.5 &lt; g &lt; (q/2) ** 0.5 assert math.gcd(f, q * g) == 1  h = (integer_ring.modinv(f,q) * g) % q  public_key = h private_key = (f,g)  print(\"private key:\", private_key) print(\"public key:\", public_key) <pre>private key: (231241, 195698)\npublic key: 79751031608\n</pre> In\u00a0[2]: Copied! <pre>m = 123456\nr = 101010\n\nassert 0 &lt; m &lt; (q/4) ** 0.5\nassert 0 &lt; r &lt; (q/2) ** 0.5\n\nh = public_key\ne = (r * public_key + m) % q\n\nplaintext = m\nciphertext = e\n\nprint(\"plaintext:\", plaintext)\nprint(\"ciphertext:\", ciphertext)\n</pre> m = 123456 r = 101010  assert 0 &lt; m &lt; (q/4) ** 0.5 assert 0 &lt; r &lt; (q/2) ** 0.5  h = public_key e = (r * public_key + m) % q  plaintext = m ciphertext = e  print(\"plaintext:\", plaintext) print(\"ciphertext:\", ciphertext) <pre>plaintext: 123456\nciphertext: 91183651259\n</pre> In\u00a0[3]: Copied! <pre>f,g = private_key\ne = ciphertext\n\na = (f * e) % q\nb = (integer_ring.modinv(f, g) * a) % g\n\nprint(\"decrypted message:\", b)\n\nassert b == plaintext\n</pre> f,g = private_key e = ciphertext  a = (f * e) % q b = (integer_ring.modinv(f, g) * a) % g  print(\"decrypted message:\", b)  assert b == plaintext <pre>decrypted message: 123456\n</pre> In\u00a0[5]: Copied! <pre>from lbpqc.primitives.lattice import reductions\nimport numpy as np\n\nv1 = np.array([1,h])\nv2 = np.array([0,q])\nV = np.array([v1, v2])\n\nW = reductions.GLR_2dim(V)\nw1 = W[0]\nw2 = W[1]\n\nprint(\"w1:\", w1, \"||w1||:\", np.linalg.norm(w1))\nprint(\"w2:\", w1, \"||w2||:\", np.linalg.norm(w2))\n\nF, G = np.rint(w1).astype(int)\nprint()\n\nprint(\"F:\", F)\nprint(\"G:\", G)\n\nprint(\"secret f:\", f)\nprint(\"secret g:\", g)\n</pre> from lbpqc.primitives.lattice import reductions import numpy as np  v1 = np.array([1,h]) v2 = np.array([0,q]) V = np.array([v1, v2])  W = reductions.GLR_2dim(V) w1 = W[0] w2 = W[1]  print(\"w1:\", w1, \"||w1||:\", np.linalg.norm(w1)) print(\"w2:\", w1, \"||w2||:\", np.linalg.norm(w2))  F, G = np.rint(w1).astype(int) print()  print(\"F:\", F) print(\"G:\", G)  print(\"secret f:\", f) print(\"secret g:\", g) <pre>w1: [-231241. -195698.] ||w1||: 302935.8138038486\nw2: [-231241. -195698.] ||w2||: 410253.69316192635\n\nF: -231241\nG: -195698\nsecret f: 231241\nsecret g: 195698\n</pre> <p>As we can see using only public parameters of the cryptosystem, we managed to retrieve secret key by interpreting the underlying problem as SVP in dimension 2 Lattice.</p>"},{"location":"examples/attacking_congruential_pkc/#attacking-a-congruential-public-key-cryptosystem-using-gaussian-lattice-reduction-in-2-dimension","title":"Attacking a congruential public key cryptosystem using Gaussian lattice reduction in 2 dimension\u00b6","text":"<p>In this example we use our library to first construct a Congruential Public Key Cryptosystem and then attack it and retrieve private key using Gaussian lattice reduction.</p>"},{"location":"examples/attacking_congruential_pkc/#congruential-public-key-cryptosystem","title":"Congruential Public Key cryptosystem\u00b6","text":""},{"location":"examples/attacking_congruential_pkc/#key-creation","title":"Key creation\u00b6","text":"<p>We start by choosing a large integer modulus $q$ which will be a public parameter of the cryptosystem. Then we need to choose two secret integers $f$ and $g$ that will form private key such that: $$ \\begin{aligned}  0 &lt; &amp;f &lt; \\sqrt{q/2} \\\\ \\sqrt{q/4} &lt; &amp;g &lt; \\sqrt{q/2} \\end{aligned} $$ We will be calculating multiplicative modular inverses so we need to make sure that they exists: $$ \\begin{aligned} \\gcd(f,q) &amp;= 1 \\\\ \\gcd(f,g) &amp;= 1 \\end{aligned} $$ we then calculate $$ h \\equiv f^{-1} g \\mod{q} $$ that value will serve as our public key. Let's see this in code</p>"},{"location":"examples/attacking_congruential_pkc/#encryption","title":"Encryption\u00b6","text":"<p>In order to perform encryption we have to chose plaintext integer $m$ that we want to encrypt and random integer $r$ that will serve as noise. $m$ must satisfy $ 0 &lt; m &lt; \\sqrt{q/4} $ and $r$ must satisfy $ 0 &lt; r &lt; \\sqrt{q/2} $. We can then use public key $h$ to compute ciphertext $e$ with the following formula: $$ e \\equiv rh + m \\mod{q} $$</p>"},{"location":"examples/attacking_congruential_pkc/#decryption","title":"Decryption\u00b6","text":"<p>We will use private key to decrypt the message. First we compute the intermidiate value $$ a \\equiv fe \\mod{q} $$ and then retrieve the plaintext $$ b \\equiv f^{-1}a \\mod{g} $$ it's important to notice that we calculate multiplicative inverse of $f$ modulo $g$ this time and not modulo $q$ as we did when creating the key. The $b$ should be equal plaintext $m$.</p>"},{"location":"examples/attacking_congruential_pkc/#attacking-the-cryptosystem","title":"Attacking the cryptosystem\u00b6","text":"<p>Unfortunetly this cryptosystem isn't very secure. In order to break it, all the attacker needs is to find two positive integers $F$ and $G$ that will satisfy the following equation $$ Fh \\equiv G \\mod{q} $$ and this integers have to be sufficiently small $$ F = \\mathcal{O}(\\sqrt{q}) \\quad \\textrm{and} \\quad G = \\mathcal{O}(\\sqrt{q}) $$ We can rewrite this congruence as $$ Fh = G + qR $$ It's then quite easy to reformulate this problem into finding shortest vector in lattice. Let's define two vectors $$ \\begin{aligned} v_1 &amp;= (1,h)\\\\ v_2 &amp;= (0,q) \\end{aligned} $$ To break the cryptosystem we have to find a linear combination $$ \\boldsymbol{w} = a_1 \\boldsymbol{v_1} + a_2 \\boldsymbol{v_2}; \\quad a_1, a_2 \\in \\mathbb{Z} $$ such that $\\boldsymbol{w}$ has length $\\mathcal{O}(\\sqrt{q})$. To put it in a lattice's terms. We need to find a short nonzero vector in the set of two-dimensional lattice $$ L = \\{a_1 \\boldsymbol{v_1} + a_2 \\boldsymbol{v_2} \\; : \\; a_1, a_2 \\in \\mathbb{Z} \\} $$ It turns out that for two dimensional lattices this problem is quite trivial</p>"},{"location":"examples/attacking_congruential_pkc/#gaussian-lattice-reduction-in-dimension-2","title":"Gaussian Lattice Reduction in Dimension 2\u00b6","text":""},{"location":"examples/attacking_discrete_knapsack_pkc/","title":"Subset sum PKC","text":"In\u00a0[1]: Copied! <pre>import math\nimport itertools\n\nis_superincreasing = lambda xs: all((j &gt;= 2 * i for i,j in itertools.pairwise(xs)))\n\nr = [3,11,24,50,115]\nA = 113\nB = 250\n\nassert is_superincreasing(r)\nassert B &gt; 2 * r[-1]\nassert math.gcd(A,B) == 1\n\nM = [(A * ri) % B for ri in r]\n\nassert not is_superincreasing(M)\n\nprivate_key = (r, A, B)\npublic_key = M\n\nprint(\"private key:\", private_key)\nprint(\"public key:\", public_key)\n</pre> import math import itertools  is_superincreasing = lambda xs: all((j &gt;= 2 * i for i,j in itertools.pairwise(xs)))  r = [3,11,24,50,115] A = 113 B = 250  assert is_superincreasing(r) assert B &gt; 2 * r[-1] assert math.gcd(A,B) == 1  M = [(A * ri) % B for ri in r]  assert not is_superincreasing(M)  private_key = (r, A, B) public_key = M  print(\"private key:\", private_key) print(\"public key:\", public_key) <pre>private key: ([3, 11, 24, 50, 115], 113, 250)\npublic key: [89, 243, 212, 150, 245]\n</pre> In\u00a0[2]: Copied! <pre>x = [1,0,1,0,1]\nS = sum((xi * Mi for xi, Mi in zip(x, M) if xi))\n\nplaintext = x\nciphertext = S\n\nprint(\"plaintext:\", plaintext)\nprint(\"ciphertext:\", ciphertext)\n</pre> x = [1,0,1,0,1] S = sum((xi * Mi for xi, Mi in zip(x, M) if xi))  plaintext = x ciphertext = S  print(\"plaintext:\", plaintext) print(\"ciphertext:\", ciphertext) <pre>plaintext: [1, 0, 1, 0, 1]\nciphertext: 546\n</pre> In\u00a0[3]: Copied! <pre>from lbpqc.primitives.integer.integer_ring import modinv\n\nr, A, B = private_key\nM = public_key\nS = ciphertext\n\nSprim = (modinv(A, B) * S) % B\n\n\ny = [0 for _ in r]\nfor i, ri in enumerate(r[::-1]):\n    if ri &lt;= Sprim:\n        y[i] = 1\n        Sprim = Sprim - ri\n\ny = y[::-1]\nprint(\"decrypted message:\", y)\nassert y == x\n</pre> from lbpqc.primitives.integer.integer_ring import modinv  r, A, B = private_key M = public_key S = ciphertext  Sprim = (modinv(A, B) * S) % B   y = [0 for _ in r] for i, ri in enumerate(r[::-1]):     if ri &lt;= Sprim:         y[i] = 1         Sprim = Sprim - ri  y = y[::-1] print(\"decrypted message:\", y) assert y == x <pre>decrypted message: [1, 0, 1, 0, 1]\n</pre> In\u00a0[14]: Copied! <pre>import numpy as np\nfrom lbpqc.primitives.lattice import reductions\n\nn = len(M)\nA = np.identity(n + 1, dtype=int) * 2\nA[-1] = 1\nA[:-1,-1] = M\nA[-1,-1] = S\nA_LLL = reductions.LLL(A).astype(int)\nw = A_LLL[0]\nprint(\"short vector in LLL reduced basis:\")\nprint(\"w = \", w)\nx = (w @ np.linalg.inv(A)).astype(int)\n\nx, y = x[:-1], x[-1]\nprint(x)\nprint(np.dot(np.array(M), x))\nprint(-y * S)\n</pre> import numpy as np from lbpqc.primitives.lattice import reductions  n = len(M) A = np.identity(n + 1, dtype=int) * 2 A[-1] = 1 A[:-1,-1] = M A[-1,-1] = S A_LLL = reductions.LLL(A).astype(int) w = A_LLL[0] print(\"short vector in LLL reduced basis:\") print(\"w = \", w) x = (w @ np.linalg.inv(A)).astype(int)  x, y = x[:-1], x[-1] print(x) print(np.dot(np.array(M), x)) print(-y * S) <pre>short vector in LLL reduced basis:\nw =  [-1  1 -1  1 -1  0]\n[-1  0 -1  0 -1]\n-546\n-546\n</pre>"},{"location":"examples/attacking_discrete_knapsack_pkc/#attacking-a-discrete-knapsack-public-key-cryptosystem-using-lll-lattice-reduction","title":"Attacking a Discrete Knapsack Public Key Cryptosystem using LLL lattice reduction\u00b6","text":"<p>In this example we will use our library to construct a Discrete Knapsack Public Key Cryptosystem and then attack it and retrieve private key using LLL lattice reduction</p>"},{"location":"examples/attacking_discrete_knapsack_pkc/#discrete-knapsack-public-key-cryptosystem","title":"Discrete Knapsack Public Key Cryptosystem\u00b6","text":"<p>In this cryptosystem we assume security by using Discrete Knapsack Packing Problem which is NP-hard. In theory this should a be very strong assurance. However in practice in order to create a trapdoor we will have to use special kind of sequences (superincreasing sequences), that will allow us to find and exploit vulnerabilities of the cryptosystem without actually solving the underlying general NP-hard problem.</p>"},{"location":"examples/attacking_discrete_knapsack_pkc/#discrete-knapsack-packing-problem","title":"Discrete Knapsack Packing Problem\u00b6","text":"<p>Given a list of positive integers $(M_1, M_2, ..., M_n)$ and another integer $S$ find a subset of the elements in the list that sums to $S$. This problem in general is very hard to solve. However if we use so called superincreasing sequences as our list, we can use straightforward greedy algorithm to find a solution. We say that list of positive integers $(r_1, r_2, ... , r_n)$ is superincreasing if $$ r_{i+1} \\geq 2r_i \\quad \\text{for all} \\; 1 \\leq i \\leq n - 1 $$ If we are asked to solve knapsack problem $(M, S)$, where $M$ is integer sequence and $S$ is the sum we have to obtain then if $M$ is superincreasing sequence we can find a solution with following algorithm. $$ \\begin{aligned} \\text{1.} &amp; \\text{find the largest element of} \\; M \\; \\text{that is smaller than} \\; S. \\newline \\text{2.} &amp; \\text{subtract this element from} \\; S. \\newline \\text{3.} &amp; \\text{repeat until the problem is solved}. \\end{aligned} $$</p> <p>The idea behind Discrete Knapsack Cryptosystems is quite simple. If we could construct superincreasing sequence and somehow obstruct it to the public eye, then it would appear that the best way to solve it is by using some kind of exponential algorithm. We could however easily find the solution by utilizing the greedy algorithm on unobstucted sequence.</p>"},{"location":"examples/attacking_discrete_knapsack_pkc/#key-creation","title":"Key creation\u00b6","text":"<p>Let's choose some superincreasing sequence $\\boldsymbol{r} = (r_1, ...., r_n)$ and two large secret integers $A$ and $B$ satisfying $$     B &gt; 2r_n \\quad \\text{and} \\quad \\gcd(A,B) = 1. $$ We can then create new sequence $\\boldsymbol{M}$ that is not superincreasing with the following method $$ M_i \\equiv Ar_i \\mod B \\quad \\text{for all} \\; 1 \\leq i \\leq n $$ $(\\boldsymbol{r}, A, B)$ is our private key and $\\boldsymbol{M}$ is our public key.</p>"},{"location":"examples/attacking_discrete_knapsack_pkc/#encryption","title":"Encryption\u00b6","text":"<p>Our plaintext has a form of binary vector $\\boldsymbol{x}$ $i_{th}$ coefficient of the vector indicates if we count the $i_{th}$ sequence element into the knapsack sum. The obtained sum $S$ is our ciphertext.</p>"},{"location":"examples/attacking_discrete_knapsack_pkc/#decryption","title":"Decryption\u00b6","text":"<p>Upon receiving the sum $S$. We can transform it into \"space\" of our superincreasing sequence $$ S' \\equiv A^{-1} S \\mod{B} $$ Then we use the greedy algorithm on our secret superincreasing sequence to find the binary vector $\\boldsymbol{y}$ that will be our decrypted message.</p>"},{"location":"examples/attacking_discrete_knapsack_pkc/#attacking-the-cryptosystem","title":"Attacking the cryptosystem\u00b6","text":""},{"location":"examples/constructing_and_attacking_GGH_pkc/","title":"GGH PKC","text":"In\u00a0[4]: Copied! <pre>import numpy as np\nimport lbpqc.primitives.lattice.fullrank as frl\nfrom lbpqc.primitives.matrix import HNF\n\n# let's choose the vectors for a good basis\nv1 = np.array([-97, 19, 19])\nv2 = np.array([-36, 30, 86])\nv3 = np.array([-184, -64, 78])\n\nV = np.array([v1, v2, v3])\nprint(\"Good basis V\")\nprint(V)\nprint(f\"Hadamard ratio for V: {frl.hadamard_ratio(V):.2f}\")\nprint()\n# Now let's calculate bad basis W as a Hermite normal form of V\nW, *_ = HNF(V)\nprint(\"Bad basis W:\")\nprint(W)\nprint(f\"Hadamard ratio for W: {frl.hadamard_ratio(W)}\")\n</pre> import numpy as np import lbpqc.primitives.lattice.fullrank as frl from lbpqc.primitives.matrix import HNF  # let's choose the vectors for a good basis v1 = np.array([-97, 19, 19]) v2 = np.array([-36, 30, 86]) v3 = np.array([-184, -64, 78])  V = np.array([v1, v2, v3]) print(\"Good basis V\") print(V) print(f\"Hadamard ratio for V: {frl.hadamard_ratio(V):.2f}\") print() # Now let's calculate bad basis W as a Hermite normal form of V W, *_ = HNF(V) print(\"Bad basis W:\") print(W) print(f\"Hadamard ratio for W: {frl.hadamard_ratio(W)}\") <pre>Good basis V\n[[ -97   19   19]\n [ -36   30   86]\n [-184  -64   78]]\nHadamard ratio for V: 0.75\n\nBad basis W:\n[[     1      1 285737]\n [     0      2 181486]\n [     0      0 429758]]\nHadamard ratio for W: 0.00033786260692220203\n</pre> In\u00a0[6]: Copied! <pre>r = np.array([-4, -3, 2])\nm = np.array([86, -35, -32])\n\ne = m @ W + r\n\nprint(f\"Encrypted message e: {e}\")\n</pre> r = np.array([-4, -3, 2]) m = np.array([86, -35, -32])  e = m @ W + r  print(f\"Encrypted message e: {e}\") <pre>Encrypted message e: [     82      13 4469118]\n</pre> In\u00a0[7]: Copied! <pre>x = frl.babai_cvp(e, V)\nd = ((x @ V) @ np.linalg.inv(W)).astype(int)\nprint(f\"Message m: {m}\")\nprint(f\"Decrypted message d: {d}\")\nassert np.all(m == d)\n</pre> x = frl.babai_cvp(e, V) d = ((x @ V) @ np.linalg.inv(W)).astype(int) print(f\"Message m: {m}\") print(f\"Decrypted message d: {d}\") assert np.all(m == d) <pre>Message m: [ 86 -35 -32]\nDecrypted message d: [ 86 -35 -32]\n</pre> <p>Let's also try to decrypt the message using only public key $W$. Then $ y = \\text{babai}(W, e) \\cdot W $.</p> In\u00a0[8]: Copied! <pre>y = frl.babai_cvp(e, W) @ W\nprint(f\"Message m: {m}\")\nprint(f\"Decrypted message y: {y}\")\n</pre> y = frl.babai_cvp(e, W) @ W print(f\"Message m: {m}\") print(f\"Decrypted message y: {y}\") <pre>Message m: [ 86 -35 -32]\nDecrypted message y: [     82      14 4367170]\n</pre> <p>Because $W$ is a bad basis, Babai's algorithm gives a very bad approximation for CVP, hence the message is incorrectly decrypted.</p> In\u00a0[9]: Copied! <pre>from lbpqc.primitives.lattice.reductions import LLL\n\nM = LLL(W)\nprint(\"LLL reduced basis M\")\nprint(M)\nprint(f\"Hadamard ratio for M: {frl.hadamard_ratio(M):.2f}\")\n\ns = frl.babai_cvp(e, M)\ns = ((s @ M) @ np.linalg.inv(W)).astype(int)\nprint(f\"Message m: {m}\")\nprint(f\"Decrypted message s: {s}\")\nassert np.all(m==s)\n</pre> from lbpqc.primitives.lattice.reductions import LLL  M = LLL(W) print(\"LLL reduced basis M\") print(M) print(f\"Hadamard ratio for M: {frl.hadamard_ratio(M):.2f}\")  s = frl.babai_cvp(e, M) s = ((s @ M) @ np.linalg.inv(W)).astype(int) print(f\"Message m: {m}\") print(f\"Decrypted message s: {s}\") assert np.all(m==s) <pre>LLL reduced basis M\n[[ -36.   30.   86.]\n [ -61.  -11.  -67.]\n [  10. -102.   40.]]\nHadamard ratio for M: 0.96\nMessage m: [ 86 -35 -32]\nDecrypted message s: [ 86 -35 -32]\n</pre> <p>Using only public key $W$ we managed to decrypt the message $e$ by utilizing the LLL algorithm.</p>"},{"location":"examples/constructing_and_attacking_GGH_pkc/#constructing-and-attacking-ggh-public-key-cryptosystem","title":"Constructing and attacking GGH public key cryptosystem\u00b6","text":"<p>GGH cryptosystem named after it's authors - Goldwasser, Goldreich and Halevi is one of the earlier cryptosystems based on some lattice problem. In case for GGH the underlying problem is CVP (Closest Vector Problem). In order to construct a trapdoor, the concept of good and bad basis is created. Although the GGH has already been already successfully cryptanalyzed for practical parameters sizes, due to it's relative simplicity it serves as a good introduction to latticed based cryptography and cryptanalysis.</p>"},{"location":"examples/constructing_and_attacking_GGH_pkc/#ggh-public-key-cryptosystem","title":"GGH Public Key Cryptosystem\u00b6","text":"<p>The key concept behind the GGH cryptosystem is the notion of good and bad basis. Good basis consists of relativly short and orthogonal lattice vectors, which allows (with correctly choosen parameters) for solving CVP with sufficiently good approximation. Bad basis consists of long and highly non-orthogonal lattice vectors.</p>"},{"location":"examples/constructing_and_attacking_GGH_pkc/#key-creation","title":"Key creation\u00b6","text":"<p>Let's strart by choosing a set of linearly independent vectors that will server as a good basis (to check whether a basis is good we can calculate it's Hadamard ratio) $$ v_1,...,v_n \\in \\mathbb{Z}^{n} $$ Let $V$ be a $n$-by-$n$ matrix whose rows are the vectors $v_1, ..., v_n$ $$ \\begin{bmatrix} v_1 \\newline \\vdots \\newline v_n \\end{bmatrix} $$ In order to create the hardest possible basis that spans the same lattice we can use the Hermite normal form of the matrix $V$, which is an analogue of reduced echelon form for matrices over the integers $\\mathbb{Z}$ and is the same for every basis of a given lattice. Let $$ W = \\text{hnf}(V) $$ The $V$ matrix is a good basis and will serve as a private key, while the matrix $W$ is a bad basis and will be used as public key.</p>"},{"location":"examples/constructing_and_attacking_GGH_pkc/#encryption","title":"Encryption\u00b6","text":"<p>Let $ m \\in \\mathbb{Z}^{n} $ be an integer vector representing plaintext that is to be encrypted and   $r \\in \\mathbb{R}^{n}$ be a small perturbation vector that will act as a noise. In order to encrypt vector $m$ using public key $W$ and noise vector $r$ we compute $$ e = m \\cdot W + r $$ because we add noise vector $r$, the vector $e$ is not a lattice point itself, but it should be close to the lattice point $mW$ since $r$ is small. The vector $e$ is our encrypted message.</p>"},{"location":"examples/constructing_and_attacking_GGH_pkc/#decryption","title":"Decryption\u00b6","text":"<p>In order to decrypt vector $e$ we wil use Babai's algorithm. Given some lattice basis $B$ and some vector $w$, Babai's algorithm will find approxCVP in a following way $$ \\begin{aligned} \\text{1.} &amp; \\text{Write the vector} \\; w \\; \\text{in coordinates of basis} \\; B \\; \\text{by solving} \\; w = x \\cdot B.\\newline \\text{2.} &amp; \\; x \\in \\mathbb{R}^{n} \\; \\text{so round it's coefficients to the nearest integer.}\\newline \\text{3.} &amp; \\text{return x.} \\end{aligned} $$ $$ x = \\text{babai}(V,e) $$ Vector $x$ is written using private basis, so to get to the message we need to change basis to public basis. $$ d = (x \\cdot V) \\cdot W^{-1} $$ Vector $d$ is the encrypted message.</p>"},{"location":"examples/constructing_and_attacking_GGH_pkc/#attacking-the-underlying-problem","title":"Attacking the underlying problem\u00b6","text":"<p>Unfortunetly GGH cryptosystem is not very secure. The only thing we need to break it, is to somehow transform a known bad basis $W$ into some better basis $M$. We can use the LLL algorithm to do just that.</p>"},{"location":"examples/constructing_and_attacking_NTRU_pkc/","title":"NTRU PKC","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nfrom lbpqc.primitives.polynomial.polyqring import PolyQuotientRing, from_ideal\nfrom lbpqc.primitives.lattice import fullrank, reductions\nfrom lbpqc.primitives.integer.integer_ring import center_mod_reduce\n</pre> import numpy as np from lbpqc.primitives.polynomial.polyqring import PolyQuotientRing, from_ideal from lbpqc.primitives.lattice import fullrank, reductions from lbpqc.primitives.integer.integer_ring import center_mod_reduce In\u00a0[2]: Copied! <pre># Let's choose NTRU parameters and private key (f,g)\nN, p, q, d = 7, 3, 41, 2\nRq = from_ideal(\"-\", N, q)#(X^N + 1)\nRp = from_ideal(\"-\", N, p)#(X^N + 1)\n\nf = np.array([-1, 0, 1, 1, -1, 0, 1], dtype=int) #f(x) = x^6 - x^4 + x^3 + x^2 - 1\ng = np.array([0, -1, -1, 0, 1, 0, 1], dtype=int) #g(x) = x^6 + x^4 - x^2 - x\n</pre> # Let's choose NTRU parameters and private key (f,g) N, p, q, d = 7, 3, 41, 2 Rq = from_ideal(\"-\", N, q)#(X^N + 1) Rp = from_ideal(\"-\", N, p)#(X^N + 1)  f = np.array([-1, 0, 1, 1, -1, 0, 1], dtype=int) #f(x) = x^6 - x^4 + x^3 + x^2 - 1 g = np.array([0, -1, -1, 0, 1, 0, 1], dtype=int) #g(x) = x^6 + x^4 - x^2 - x In\u00a0[7]: Copied! <pre># Now lets compute inverses Fq and Fp\nFq = Rq.inv(f)\nFp = Rp.inv(f)\n\n# Lets check if the inverses are correct\nprint(\"f^-1 in Rq:\")\nprint(Fq)\nprint(\"f * f^-1:\", Rq.mul(f, Fq))\nprint()\nprint(\"f^-1 in Rp:\")\nprint(Fp)\nprint(\"f * f^-1:\", Rp.mul(f, Fp))\nprint()\n\n\n# Now let's calculate public key h\nh = Rq.mul(Fq, g)\nprint(\"h = Fq * g:\")\nprint(h)\nprint()\n\nprint(\"Private key: (f(x), Fp(x))\")\nprint(\"f(x) = \", f)\nprint(\"g(x) = \", g)\nprint()\nprint(\"Public key: h(x)\")\nprint(\"h(x) = \", h)\n\nsk = (f, Fp)\npk = h\n</pre> # Now lets compute inverses Fq and Fp Fq = Rq.inv(f) Fp = Rp.inv(f)  # Lets check if the inverses are correct print(\"f^-1 in Rq:\") print(Fq) print(\"f * f^-1:\", Rq.mul(f, Fq)) print() print(\"f^-1 in Rp:\") print(Fp) print(\"f * f^-1:\", Rp.mul(f, Fp)) print()   # Now let's calculate public key h h = Rq.mul(Fq, g) print(\"h = Fq * g:\") print(h) print()  print(\"Private key: (f(x), Fp(x))\") print(\"f(x) = \", f) print(\"g(x) = \", g) print() print(\"Public key: h(x)\") print(\"h(x) = \", h)  sk = (f, Fp) pk = h <pre>f^-1 in Rq:\n[37  2 40 21 31 26  8]\nf * f^-1: [1]\n\nf^-1 in Rp:\n[1 1 1 1 0 2 1]\nf * f^-1: [1]\n\nh = Fq * g:\n[30 26  8 38  2 40 20]\n\nPrivate key: (f(x), Fp(x))\nf(x) =  [-1  0  1  1 -1  0  1]\ng(x) =  [ 0 -1 -1  0  1  0  1]\n\nPublic key: h(x)\nh(x) =  [30 26  8 38  2 40 20]\n</pre> In\u00a0[8]: Copied! <pre># plaintext\nm = np.array([ 1,-1, 1, 1, 0,-1], dtype=int)\nprint(\"plaintext m(x) =\", m)\n# random element\nr = np.array([-1, 1, 0, 0, 0,-1, 1], dtype=int)\nprint(\"random element r(x) =\", r) \n\nprint()\n# ciphertext\ne = Rq.add(p * Rq.mul(r, pk), m)\nprint(\"ciphertext e(x) =\", e)\n</pre> # plaintext m = np.array([ 1,-1, 1, 1, 0,-1], dtype=int) print(\"plaintext m(x) =\", m) # random element r = np.array([-1, 1, 0, 0, 0,-1, 1], dtype=int) print(\"random element r(x) =\", r)   print() # ciphertext e = Rq.add(p * Rq.mul(r, pk), m) print(\"ciphertext e(x) =\", e) <pre>plaintext m(x) = [ 1 -1  1  1  0 -1]\nrandom element r(x) = [-1  1  0  0  0 -1  1]\n\nciphertext e(x) = [25  3 40  2  4 19 31]\n</pre> In\u00a0[10]: Copied! <pre>a = center_mod_reduce(Rq.mul(sk[0], e), q)\nd = center_mod_reduce(Rp.mul(sk[1], a), p)\n\nprint(\"Decrypted message d:\")\nprint(d)\nprint(\"Original message m:\")\nprint(m)\n</pre> a = center_mod_reduce(Rq.mul(sk[0], e), q) d = center_mod_reduce(Rp.mul(sk[1], a), p)  print(\"Decrypted message d:\") print(d) print(\"Original message m:\") print(m) <pre>Decrypted message d:\n[ 1 -1  1  1  0 -1]\nOriginal message m:\n[ 1 -1  1  1  0 -1]\n</pre> In\u00a0[12]: Copied! <pre>from lbpqc.primitives.polynomial.poly import monomial, pad\nfrom lbpqc.primitives.lattice.reductions import LLL\n</pre> from lbpqc.primitives.polynomial.poly import monomial, pad from lbpqc.primitives.lattice.reductions import LLL In\u00a0[13]: Copied! <pre>L11 = np.identity(N, int)\nL12 = np.array([pad(Rq.mul(monomial(1, i), h), N - 1) for i in range(N)])\nL21 = np.zeros((N,N), int)\nL22 = q * np.identity(N, int)\n\nNTRU_B = np.block([[L11, L12], [L21, L22]])\nprint(\"NTRU as lattice:\")\nprint(NTRU_B)\n</pre> L11 = np.identity(N, int) L12 = np.array([pad(Rq.mul(monomial(1, i), h), N - 1) for i in range(N)]) L21 = np.zeros((N,N), int) L22 = q * np.identity(N, int)  NTRU_B = np.block([[L11, L12], [L21, L22]]) print(\"NTRU as lattice:\") print(NTRU_B) <pre>NTRU as lattice:\n[[ 1  0  0  0  0  0  0 30 26  8 38  2 40 20]\n [ 0  1  0  0  0  0  0 20 30 26  8 38  2 40]\n [ 0  0  1  0  0  0  0 40 20 30 26  8 38  2]\n [ 0  0  0  1  0  0  0  2 40 20 30 26  8 38]\n [ 0  0  0  0  1  0  0 38  2 40 20 30 26  8]\n [ 0  0  0  0  0  1  0  8 38  2 40 20 30 26]\n [ 0  0  0  0  0  0  1 26  8 38  2 40 20 30]\n [ 0  0  0  0  0  0  0 41  0  0  0  0  0  0]\n [ 0  0  0  0  0  0  0  0 41  0  0  0  0  0]\n [ 0  0  0  0  0  0  0  0  0 41  0  0  0  0]\n [ 0  0  0  0  0  0  0  0  0  0 41  0  0  0]\n [ 0  0  0  0  0  0  0  0  0  0  0 41  0  0]\n [ 0  0  0  0  0  0  0  0  0  0  0  0 41  0]\n [ 0  0  0  0  0  0  0  0  0  0  0  0  0 41]]\n</pre> In\u00a0[15]: Copied! <pre>LLL_B = LLL(NTRU_B).astype(int)\nw = LLL_B[0]\nprint(\"Short vector from LLL reduced basis:\")\nprint(w)\nf_prim = w[:N]\ng_prim = w[N:]\n\nf_prim_inv_q = Rq.inv(f_prim)\nf_prim_inv_p = Rp.inv(f_prim)\n\nprint(\"f'^-1 in Rq:\")\nprint(f_prim_inv_q)\nprint(\"f'^-1 * f':\", Rq.mul(f_prim_inv_q, f_prim))\nprint()\n\nprint(\"f'^-1 in Rp:\")\nprint(f_prim_inv_p)\nprint(\"f'^-1 * f':\", Rp.mul(f_prim_inv_p, f_prim))\nprint()\n</pre> LLL_B = LLL(NTRU_B).astype(int) w = LLL_B[0] print(\"Short vector from LLL reduced basis:\") print(w) f_prim = w[:N] g_prim = w[N:]  f_prim_inv_q = Rq.inv(f_prim) f_prim_inv_p = Rp.inv(f_prim)  print(\"f'^-1 in Rq:\") print(f_prim_inv_q) print(\"f'^-1 * f':\", Rq.mul(f_prim_inv_q, f_prim)) print()  print(\"f'^-1 in Rp:\") print(f_prim_inv_p) print(\"f'^-1 * f':\", Rp.mul(f_prim_inv_p, f_prim)) print() <pre>Short vector from LLL reduced basis:\n[ 1  0 -1  1  0 -1 -1 -1  0 -1  0  1  1  0]\nf'^-1 in Rq:\n[20 10 15 33  4 39  1]\nf'^-1 * f': [1]\n\nf'^-1 in Rp:\n[2 0 1 2 2 2 2]\nf'^-1 * f': [1]\n\n</pre> In\u00a0[16]: Copied! <pre>a_prim = center_mod_reduce(Rq.mul(f_prim, e), q)\nd_prim = center_mod_reduce(Rp.mul(f_prim_inv_p, a_prim), p)\n\nprint(\"Decrypted message d:\")\nprint(d_prim)\nprint(\"Original message m:\")\nprint(m)\n</pre> a_prim = center_mod_reduce(Rq.mul(f_prim, e), q) d_prim = center_mod_reduce(Rp.mul(f_prim_inv_p, a_prim), p)  print(\"Decrypted message d:\") print(d_prim) print(\"Original message m:\") print(m) <pre>Decrypted message d:\n[ 1 -1  1  1  0 -1]\nOriginal message m:\n[ 1 -1  1  1  0 -1]\n</pre>"},{"location":"examples/constructing_and_attacking_NTRU_pkc/#constructing-and-attacking-ntru-public-key-cryptosystem","title":"Constructing and attacking NTRU public key cryptosystem\u00b6","text":"<p>In contrast to cryptosystems such as RSA, Diffie-Hellman or ECC which are based on Group operations, the NTRU cryptosystem is a ring-based cryptosystem, specifically convolution polynomial rings, but it's underlying hard mathematical problem can also be interpreted as SVP or CVP in a lattice.</p>"},{"location":"examples/constructing_and_attacking_NTRU_pkc/#ntruencrypt","title":"NTRUEncrypt\u00b6","text":"<p>The NTRU public key cryptosystem, parameterized by integers $N$, $p$, $q$ and $d$ such that $$ \\begin{aligned} \\text{1.}&amp;\\; N \\in \\mathbb{P} \\; \\text{is prime} \\newline \\text{2.}&amp;\\; \\gcd(N,q) = \\gcd(p,q) = 1 \\newline \\text{3.}&amp;\\; d &gt; 0 \\newline \\text{4.}&amp;\\; q &gt; (6d + 1)p \\end{aligned} $$ is based on operations in three polynomial rings $R, R_p, R_q$ $$ R = \\frac{\\mathbb{Z}[X]}{X^{N} - 1}, \\quad R_p = \\frac{\\mathbb{Z}_p[X]}{X^{N} - 1}, \\quad R_q = \\frac{\\mathbb{Z}_q[X]}{X^{N} - 1} $$ and ternary polynomials defined for any positive integers $d_1$ and $d_2$ as $$ \\mathcal{T}(d_1, d_2) = \\left\\{ a(x) \\in R \\; \\middle| \\; \\begin{array}{l} a(x) \\; \\text{has} \\; d_1 \\; \\text{coefficients equal to 1,}\\newline a(x) \\; \\text{has} \\; d_2 \\; \\text{coefficients equal to -1,}\\newline a(x) \\; \\text{has all other coefficients equal to 0} \\end{array} \\right\\} $$</p>"},{"location":"examples/constructing_and_attacking_NTRU_pkc/#key-creation","title":"Key creation\u00b6","text":"<p>Let $(N, p, q, d)$ be publicly known parameters of the NTRU cryptosystem, chosen by some trusted authority. Private  key consists of two randomly chosen polynomials $$ f(x) \\in \\mathcal{T}(d + 1, d) \\qquad \\text{and} \\qquad g(x) \\in \\mathcal{T}(d, d) $$ To set up public key we first need to calculate inverses $$ F_q(x) = f(x)^{-1} \\; \\text{in} \\; R_q \\qquad \\text{and} \\qquad F_p = f(x)^{-1} \\; \\text{in} \\; R_p $$ The $f(x)$ must be chosen such that inverses $F_q(x)$ and $F_p(x)$ exists.</p> <p>The polynomial $h(x)$ defined as $$ h(x) = F_q(x) \\cdot g(x) \\; \\text{in} \\; R_q $$ will be a public key</p> <p>Private key: $(f(x), g(x))$ Public key: $h(x)$</p>"},{"location":"examples/constructing_and_attacking_NTRU_pkc/#encryption","title":"Encryption\u00b6","text":"<p>Plaintext $m$ has a form of polynomial $m(x) \\in R$ whose coefficients satisfy $ \\; -\\frac{1}{2}p &lt; m_i \\leq \\frac{1}{2}p $. In order to encrypt $m$ we also need a random polynomial $r(x) \\in \\mathcal{T}(d,d)$ then $$ e(x) \\equiv p h(x) \\cdot r(x) + m(x) \\quad \\mod q $$ is a ciphertext and $e(x) \\in R_q$</p>"},{"location":"examples/constructing_and_attacking_NTRU_pkc/#decryption","title":"Decryption\u00b6","text":"<p>To decrypt ciphertext $e(x)$ we first need to compute $$ a(x) \\equiv f(x) \\cdot e(x) \\quad \\mod q $$ then $$ b(x) \\equiv F_p(x) \\cdot \\text{center\\_lift} (a(x)) \\quad \\mod p $$ is equal to the plaintext $m(x)$</p>"},{"location":"examples/constructing_and_attacking_NTRU_pkc/#ntru-as-a-lattice","title":"NTRU as a lattice\u00b6","text":"<p>Given NTRU cryptosystem with parameters $(N,p,q,d)$ we are going to identify each pair of polynomials $$ a(x) = a_0 + \\ldots + a_{N-1}x^{N-1} \\qquad \\text{and} \\qquad b(x) = b_0 + \\ldots + b_{N-1}x^{N-1} $$ in $R$ with $2N$-dimensional vector $$ (a,b) = (a_0, \\ldots, a_{N-1}, b_0, \\ldots, b_{N-1}) \\in \\mathbb{Z}^{2N} $$</p>"}]}